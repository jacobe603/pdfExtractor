<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PDF Schedule Extractor</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    
    <!-- Optional OCR Features -->
    <script src="https://unpkg.com/tesseract.js@4/dist/tesseract.min.js"></script>
    <script src="gemini-ocr-provider.js"></script>
    <script src="ocr-table-extractor.js"></script>
    
    <!-- ZIP File Generation -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    
    <!-- PDF Annotation Support -->
    <script src="https://unpkg.com/pdf-lib@1.17.1/dist/pdf-lib.min.js"></script>
    
    <!-- BlueBeam Spaces Support -->
    <script src="bluebeam-spaces.js"></script>
    
    <!-- Settings Manager -->
    <script src="settings-manager.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #f5f5f5;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }

        .toolbar {
            background: #2c3e50;
            color: white;
            padding: 10px 20px;
            display: flex;
            align-items: center;
            gap: 15px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .toolbar h1 {
            font-size: 1.2em;
            font-weight: 600;
        }

        .file-input {
            position: relative;
            overflow: hidden;
            display: inline-block;
        }

        .file-input input[type=file] {
            position: absolute;
            left: -9999px;
        }

        .file-input label {
            background: #3498db;
            color: white;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            transition: background 0.3s;
        }

        .file-input label:hover {
            background: #2980b9;
        }

        .controls {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .btn {
            background: #27ae60;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            transition: background 0.3s;
        }

        .btn:hover {
            background: #219a52;
        }

        .btn:disabled {
            background: #95a5a6;
            cursor: not-allowed;
        }

        .main-content {
            flex: 1;
            display: flex;
            overflow: hidden;
        }

        .pdf-container {
            flex: 1;
            background: white;
            position: relative;
            overflow: auto;
            border-right: 1px solid #ddd;
        }

        .canvas-container {
            position: relative;
            display: inline-block;
            margin: 20px;
        }

        .pdf-canvas {
            border: 1px solid #ccc;
            cursor: crosshair;
        }

        .selection-overlay {
            position: absolute;
            top: 0;
            left: 0;
            pointer-events: none;
            z-index: 10;
        }

        .selection-rect {
            position: absolute;
            border: 2px dashed #e74c3c;
            background: rgba(231, 76, 60, 0.1);
            pointer-events: none;
        }

        .saved-rect {
            position: absolute;
            border: 2px solid #3498db;
            background: rgba(52, 152, 219, 0.1);
            pointer-events: all;
            cursor: pointer;
        }

        .saved-rect:hover {
            border-color: #2ecc71;
            background: rgba(46, 204, 113, 0.2);
        }

        .saved-rect.selected {
            border-color: #3498db;
            background: rgba(52, 152, 219, 0.2);
        }

        .equipment-type-GRD {
            border-color: #9b59b6;
            background: rgba(155, 89, 182, 0.1);
        }

        .equipment-type-VAV {
            border-color: #e67e22;
            background: rgba(230, 126, 34, 0.1);
        }

        .equipment-type-FANS {
            border-color: #27ae60;
            background: rgba(39, 174, 96, 0.1);
        }

        .equipment-type-RTU {
            border-color: #2980b9;
            background: rgba(41, 128, 185, 0.1);
        }

        .equipment-type-OTHER {
            border-color: #95a5a6;
            background: rgba(149, 165, 166, 0.1);
        }

        .sidebar {
            width: 300px;
            background: white;
            border-left: 1px solid #ddd;
            padding: 20px;
            overflow-y: auto;
        }

        .sidebar h3 {
            margin-bottom: 15px;
            color: #2c3e50;
        }

        .extraction-list {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .extraction-item {
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 6px;
            padding: 12px;
            cursor: pointer;
            transition: all 0.3s;
        }

        .extraction-item:hover {
            background: #e9ecef;
            border-color: #3498db;
        }

        .extraction-item.selected {
            background: #e3f2fd;
            border-color: #2196f3;
        }

        .extraction-title {
            font-weight: 600;
            color: #2c3e50;
            margin-bottom: 4px;
        }

        .extraction-coords {
            font-size: 0.9em;
            color: #6c757d;
        }

        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.5);
            align-items: center;
            justify-content: center;
        }
        
        .modal.show {
            display: flex;
        }

        .modal-content {
            background-color: white;
            margin: 5vh auto;
            padding: 30px;
            border-radius: 8px;
            width: 800px;
            max-width: 90%;
            max-height: 85vh;
            overflow-y: auto;
        }

        .modal h3 {
            margin-bottom: 20px;
            color: #2c3e50;
        }

        .form-group {
            margin-bottom: 15px;
        }

        .form-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: 500;
            color: #2c3e50;
        }

        .form-group input,
        .form-group select {
            width: 100%;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
        }

        .modal-buttons {
            display: flex;
            gap: 10px;
            justify-content: flex-end;
            margin-top: 20px;
        }

        .btn-secondary {
            background: #6c757d;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;
        }

        .btn-secondary:hover {
            background: #545b62;
        }

        .status-bar {
            background: #ecf0f1;
            padding: 8px 20px;
            border-top: 1px solid #bdc3c7;
            font-size: 0.9em;
            color: #2c3e50;
        }

        .loading {
            text-align: center;
            padding: 50px;
            color: #7f8c8d;
        }

        .page-nav {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-left: auto;
        }

        .page-nav button {
            background: #34495e;
            color: white;
            border: none;
            padding: 6px 12px;
            border-radius: 4px;
            cursor: pointer;
        }

        .page-nav button:hover {
            background: #2c3e50;
        }

        .page-nav button:disabled {
            background: #95a5a6;
            cursor: not-allowed;
        }

        .page-info {
            color: #ecf0f1;
            font-size: 0.9em;
        }

        .zoom-controls {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .zoom-controls button {
            background: #34495e;
            color: white;
            border: none;
            padding: 6px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            width: 30px;
        }

        .zoom-controls button:hover {
            background: #2c3e50;
        }

        .zoom-controls button:disabled {
            background: #95a5a6;
            cursor: not-allowed;
        }

        .zoom-controls span {
            color: #ecf0f1;
            font-size: 0.9em;
            min-width: 50px;
            text-align: center;
        }

        /* Search Text Styles */
        .search-controls {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-top: 5px;
        }

        .search-controls input[type="text"] {
            flex: 1;
            padding: 8px 12px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
        }

        .search-controls input[type="text"]:focus {
            outline: none;
            border-color: #3498db;
            box-shadow: 0 0 0 2px rgba(52, 152, 219, 0.2);
        }

        .search-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 5px 10px;
            margin: 2px 0;
            background: white;
            border: 1px solid #e0e0e0;
            border-radius: 3px;
            font-size: 13px;
        }

        .search-item-text {
            font-weight: 500;
            color: #2c3e50;
        }

        .search-item-remove {
            background: #e74c3c;
            color: white;
            border: none;
            border-radius: 2px;
            padding: 2px 6px;
            font-size: 11px;
            cursor: pointer;
            transition: background 0.3s;
        }

        .search-item-remove:hover {
            background: #c0392b;
        }

        .search-match {
            padding: 3px 6px;
            margin: 2px 0;
            background: #fff3cd;
            border: 1px solid #ffeaa7;
            border-radius: 3px;
            font-size: 12px;
            font-family: monospace;
        }

        .search-match-highlight {
            background: #ffeb3b;
            padding: 1px 3px;
            border-radius: 2px;
            font-weight: 600;
        }

        .search-no-results {
            color: #7f8c8d;
            font-style: italic;
            font-size: 12px;
            text-align: center;
            padding: 10px;
        }
        
        /* Progress Modal Styles */
        .progress-container {
            margin: 20px 0;
        }
        
        .progress-bar {
            width: 100%;
            height: 30px;
            background-color: #f0f0f0;
            border-radius: 15px;
            overflow: hidden;
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.1);
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #3498db, #2ecc71);
            border-radius: 15px;
            width: 0%;
            transition: width 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
        }
        
        .progress-text {
            text-align: center;
            margin-top: 10px;
            color: #555;
            font-size: 14px;
        }
        
        .progress-spinner {
            display: flex;
            justify-content: center;
            margin-top: 20px;
        }
        
        .spinner {
            width: 40px;
            height: 40px;
            border: 4px solid #f0f0f0;
            border-top: 4px solid #3498db;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* OCR Results Modal Styles */
        #ocr-results-modal .modal-content {
            width: 800px;
            max-width: 90%;
            max-height: 85vh;
        }

        #ocr-content-display {
            font-family: 'Courier New', Monaco, monospace;
            font-size: 12px;
            line-height: 1.4;
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 4px;
            padding: 15px;
            max-height: 400px;
            overflow-y: auto;
            white-space: pre-wrap;
            word-wrap: break-word;
            user-select: text;
            -webkit-user-select: text;
            -moz-user-select: text;
            -ms-user-select: text;
        }

        #ocr-content-display.table-format {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            white-space: normal;
        }

        #ocr-content-display.table-format table {
            width: 100%;
            border-collapse: collapse;
            margin: 0;
            font-size: 11px;
        }

        #ocr-content-display.table-format th,
        #ocr-content-display.table-format td {
            border: 1px solid #dee2e6;
            padding: 8px 6px;
            text-align: left;
            vertical-align: top;
        }

        #ocr-content-display.table-format th {
            background-color: #e9ecef;
            font-weight: bold;
            font-size: 10px;
        }

        #ocr-content-display.table-format tr:nth-child(even) {
            background-color: #f8f9fa;
        }

        #ocr-content-display.table-format tr:hover {
            background-color: #e3f2fd;
        }

        #ocr-notes-content {
            background: #fff3cd;
            border: 1px solid #ffeaa7;
            border-radius: 4px;
            padding: 15px;
            max-height: 200px;
            overflow-y: auto;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            font-size: 13px;
            line-height: 1.5;
            user-select: text;
            -webkit-user-select: text;
            -moz-user-select: text;
            -ms-user-select: text;
        }

        #ocr-notes-content ol {
            margin: 0;
            padding-left: 20px;
        }

        #ocr-notes-content li {
            margin-bottom: 8px;
            text-align: left;
        }

        #ocr-metadata {
            background: #e9ecef;
            border-radius: 4px;
            padding: 10px;
            font-size: 11px;
            color: #6c757d;
            margin-top: 15px;
        }

    </style>
</head>
<body>
    <!-- Server Status Indicator -->
    <div id="server-status" style="position: fixed; top: 10px; right: 10px; 
         padding: 5px 10px; background: rgba(0,0,0,0.7); color: white; 
         border-radius: 4px; font-size: 12px; z-index: 1000; display: flex; align-items: center; gap: 5px;">
        <span id="server-status-icon">🔴</span>
        <span id="server-status-text">Server Offline</span>
    </div>
    
    <div class="toolbar">
        <h1>PDF Schedule Extractor</h1>
        <div class="file-input">
            <input type="file" id="pdf-input" accept=".pdf">
            <label for="pdf-input">Choose PDF</label>
        </div>
        <div class="controls">
            <button class="btn" id="clear-selections" disabled>Clear All</button>
            <button class="btn" id="delete-all-extractions" style="background: #e74c3c; display: none;">🗑️ Delete All</button>
            <button class="btn" id="export-data" disabled>Export ZIP Package</button>
            <button class="btn" id="export-local" style="background: #16a085; display: none;">💾 Export to PDF Folder</button>
            <button class="btn" id="detect-spaces" style="background: #3498db;">🔍 Detect Spaces</button>
            <button class="btn" id="import-all-spaces" style="background: #9b59b6; display: none;">📥 Import All Spaces</button>
            <button class="btn" id="toggle-spaces" style="background: #2ecc71; display: none;">👁️ Hide Spaces</button>
            <button class="btn" id="open-settings" style="background: #95a5a6; margin-left: auto;">⚙️ Settings</button>
            <label style="font-size: 12px; color: #ecf0f1; margin-left: 10px;">
                <input type="checkbox" id="enable-text-extraction" checked style="margin-right: 5px;">
                Text Extraction
            </label>
        </div>
        <div class="zoom-controls">
            <button id="zoom-out" disabled>-</button>
            <span id="zoom-level">100%</span>
            <button id="zoom-in" disabled>+</button>
        </div>
        <div class="page-nav">
            <button id="prev-page" disabled>Previous</button>
            <span class="page-info">
                Page <span id="current-page">0</span> of <span id="total-pages">0</span>
            </span>
            <button id="next-page" disabled>Next</button>
        </div>
    </div>

    <div class="main-content">
        <div class="pdf-container">
            <div id="loading" class="loading">
                Select a PDF file to begin extracting schedules
            </div>
            <div class="canvas-container" id="canvas-container" style="display: none;">
                <canvas id="pdf-canvas" class="pdf-canvas"></canvas>
                <div class="selection-overlay" id="saved-overlay"></div>
                <div class="selection-overlay" id="temp-overlay"></div>
            </div>
        </div>

        <div class="sidebar">
            <!-- Session Controls -->
            <div class="session-controls" style="margin-bottom: 15px; padding: 10px; background: rgba(52, 73, 94, 0.3); border-radius: 4px;">
                <div style="display: flex; justify-content: space-between; align-items: center;">
                    <span style="font-size: 12px; color: #95a5a6;">
                        Session: <span id="session-info" style="color: #ecf0f1;">No session</span>
                    </span>
                    <div style="display: flex; gap: 5px;">
                        <button onclick="exportSession()" class="btn" style="font-size: 11px; padding: 4px 8px; background: #16a085;" title="Export Session">
                            💾 Export
                        </button>
                        <input type="file" id="import-session-input" accept=".json" style="display: none;" 
                               onchange="importSession(this.files[0])">
                        <button onclick="document.getElementById('import-session-input').click()" 
                                class="btn" style="font-size: 11px; padding: 4px 8px; background: #2980b9;" title="Import Session">
                            📂 Import
                        </button>
                        <button onclick="clearCurrentSession()" class="btn" style="font-size: 11px; padding: 4px 8px; background: #c0392b;" 
                                title="Clear Session">
                            🗑️ Clear
                        </button>
                    </div>
                </div>
            </div>
            
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                <h3 style="margin: 0;" id="extraction-header">Extracted Schedules</h3>
                <div style="display: flex; gap: 5px; align-items: center;">
                    <button class="btn" id="edit-selected" style="font-size: 12px; padding: 6px 12px; background: #3498db; display: none;">Edit Selected</button>
                    <button class="btn" id="manage-all" style="font-size: 12px; padding: 6px 12px; background: #9b59b6; display: none;">Manage All</button>
                    <button class="btn" id="extract-all" disabled style="font-size: 12px; padding: 6px 12px;">Extract All</button>
                </div>
            </div>
            <div class="extraction-list" id="extraction-list">
                <p style="color: #7f8c8d; font-style: italic;">No schedules extracted yet</p>
            </div>
            
            <div id="spaces-section" style="display: none; margin-top: 20px; border-top: 1px solid #34495e; padding-top: 15px;">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                    <h3 style="margin: 0;">🔷 BlueBeam Spaces</h3>
                    <span id="spaces-count" style="font-size: 12px; color: #95a5a6;">0 spaces</span>
                </div>
                <div id="spaces-stats" style="font-size: 12px; color: #95a5a6; margin-bottom: 10px;"></div>
                <div class="extraction-list" id="spaces-list">
                    <p style="color: #7f8c8d; font-style: italic;">No spaces detected</p>
                </div>
            </div>
        </div>
    </div>

    <div class="status-bar">
        <span id="status-text">Ready</span>
    </div>

    <div id="schedule-modal" class="modal">
        <div class="modal-content">
            <h3>Extraction Information</h3>
            <!-- 1. Equipment Type -->
            <div class="form-group">
                <label for="equipment-type">Equipment Type:</label>
                <select id="equipment-type">
                    <option value="FANS">FANS (Fan Equipment)</option>
                    <option value="VAV">VAV (Variable Air Volume)</option>
                    <option value="RTU">RTU (Roof Top Units)</option>
                    <option value="AHU">AHU (Air Handling Units)</option>
                    <option value="GRD">GRD (Grilles/Diffusers)</option>
                    <option value="DUCTING">DUCTING (Ductwork)</option>
                    <option value="CUSTOM">CUSTOM (Add Custom Type)</option>
                </select>
            </div>
            <div class="form-group" id="custom-equipment-group" style="display: none;">
                <label for="custom-equipment-type">Custom Equipment Type:</label>
                <input type="text" id="custom-equipment-type" placeholder="e.g., CHILLERS, PUMPS" style="text-transform: uppercase;">
            </div>
            
            <!-- 2. Extraction Name -->
            <div class="form-group">
                <label for="extraction-name">Extraction Name:</label>
                <input type="text" id="extraction-name" placeholder="Auto-generated from type selections">
            </div>
            
            <!-- 3. Extraction Type -->
            <div class="form-group">
                <label for="extraction-type">Extraction Type:</label>
                <select id="extraction-type">
                    <option value="schedule">Schedule</option>
                    <option value="drawing">Drawing</option>
                    <option value="table">Table</option>
                    <option value="detail">Detail</option>
                    <option value="specification">Specification</option>
                    <option value="other">Other</option>
                </select>
            </div>
            
            <!-- 4. Extraction Description -->
            <div class="form-group">
                <label for="extraction-description">Extraction Description:</label>
                <input type="text" id="extraction-description" placeholder="Brief description of the extraction">
            </div>
            
            <!-- 5. RFQ Required -->
            <div class="form-group">
                <label>
                    <input type="checkbox" id="rfq-required" style="margin-right: 5px;">
                    RFQ Required (needs 3rd party quote)
                </label>
            </div>
            
            <!-- 6. Search Text in Selection -->
            <div class="form-group">
                <label for="search-input">Search Text in Selection:</label>
                <div class="search-controls">
                    <input type="text" id="search-input" placeholder="Enter search terms..." style="flex: 1; margin-right: 10px;">
                    <button type="button" id="add-search-btn" class="btn-secondary" style="padding: 8px 12px;">Add</button>
                    <button type="button" id="search-btn" class="btn" style="padding: 8px 12px;">Search</button>
                </div>
                <div id="search-results" style="display: none; margin-top: 10px; padding: 10px; background: #f8f9fa; border: 1px solid #dee2e6; border-radius: 4px; max-height: 200px; overflow-y: auto;">
                    <div class="search-list-header" style="font-weight: 600; margin-bottom: 8px; border-bottom: 1px solid #dee2e6; padding-bottom: 5px;">
                        Current Searches:
                    </div>
                    <div id="search-list" style="margin-bottom: 10px;">
                        <!-- Search items will be added here -->
                    </div>
                    <div id="search-matches" style="border-top: 1px solid #dee2e6; padding-top: 8px; margin-top: 8px;">
                        <div class="search-matches-header" style="font-weight: 600; margin-bottom: 5px;">Matches Found:</div>
                        <div id="matches-list">
                            <!-- Search matches will be displayed here -->
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- 7. Extract Table with OCR -->
            <div class="form-group">
                <label>
                    <input type="checkbox" id="enable-table-ocr" style="margin-right: 5px;">
                    Extract Table with OCR (processed in background)
                </label>
                <div id="table-ocr-status" style="display: none; margin-top: 5px; font-size: 12px; color: #666;">
                    <!-- OCR status will be shown here when processing -->
                </div>
            </div>
            
            <!-- 8. OCR Provider -->
            <div class="form-group" id="ocr-config-group" style="display: none;">
                <label for="ocr-provider">OCR Provider:</label>
                <select id="ocr-provider" style="margin-bottom: 10px;">
                    <option value="auto">Auto (Best Available)</option>
                    <option value="gemini">Google Gemini (Recommended)</option>
                    <option value="tesseract">Tesseract.js (Fallback)</option>
                </select>
                <div id="gemini-config" style="display: none;">
                    <label for="gemini-api-key">Gemini API Key:</label>
                    <input type="password" id="gemini-api-key" placeholder="Enter your Gemini API key">
                    <div style="font-size: 12px; color: #666; margin-top: 5px;">
                        Get your API key from <a href="https://ai.google.dev/gemini-api/docs/api-key" target="_blank">Google AI Studio</a>
                    </div>
                </div>
                <div id="provider-status" style="margin-top: 10px; font-size: 12px; padding: 8px; border-radius: 4px; display: none;">
                </div>
            </div>
            <div class="modal-buttons">
                <button class="btn-secondary" id="modal-cancel">Cancel</button>
                <button class="btn" id="modal-save">Save Schedule</button>
            </div>
        </div>
    </div>
    
    <!-- Settings Modal -->
    <div id="settings-modal" class="modal">
        <div class="modal-content" style="width: 600px; max-height: 80vh; overflow-y: auto;">
            <h3>⚙️ Settings</h3>
            
            <!-- Equipment Types Section -->
            <div class="form-group">
                <label style="font-weight: bold; margin-bottom: 10px; display: block;">Equipment Types</label>
                <div id="equipment-types-list" style="max-height: 200px; overflow-y: auto; border: 1px solid #ddd; padding: 10px; margin-bottom: 10px;">
                    <!-- Will be populated dynamically -->
                </div>
                <div style="display: flex; gap: 10px;">
                    <input type="text" id="new-equipment-value" placeholder="Value (e.g., PUMP)" style="flex: 1;">
                    <input type="text" id="new-equipment-label" placeholder="Label (e.g., Pumps)" style="flex: 2;">
                    <button class="btn" onclick="addEquipmentType()" style="padding: 5px 10px;">Add</button>
                </div>
            </div>
            
            <!-- Search Presets Section -->
            <div class="form-group">
                <label style="font-weight: bold; margin-bottom: 10px; display: block;">Search Term Presets</label>
                <div id="search-presets-list" style="max-height: 150px; overflow-y: auto; border: 1px solid #ddd; padding: 10px; margin-bottom: 10px;">
                    <!-- Will be populated dynamically -->
                </div>
                <div style="display: flex; gap: 10px;">
                    <input type="text" id="new-search-preset" placeholder="Add search preset (e.g., VOLTAGE)" style="flex: 1;">
                    <button class="btn" onclick="addSearchPreset()" style="padding: 5px 10px;">Add</button>
                </div>
            </div>
            
            <!-- Default Settings Section -->
            <div class="form-group">
                <label style="font-weight: bold; margin-bottom: 10px; display: block;">Default Settings</label>
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px;">
                    <div>
                        <label for="default-equipment-type">Default Equipment Type:</label>
                        <select id="default-equipment-type" style="width: 100%;">
                            <!-- Will be populated dynamically -->
                        </select>
                    </div>
                    <div>
                        <label for="default-extraction-type">Default Extraction Type:</label>
                        <select id="default-extraction-type" style="width: 100%;">
                            <!-- Will be populated dynamically -->
                        </select>
                    </div>
                    <div>
                        <label for="default-ocr-provider">Default OCR Provider:</label>
                        <select id="default-ocr-provider" style="width: 100%;">
                            <option value="auto">Auto-detect</option>
                            <option value="gemini">Google Gemini</option>
                            <option value="tesseract">Tesseract.js</option>
                        </select>
                    </div>
                    <div>
                        <label>
                            <input type="checkbox" id="default-auto-ocr">
                            Auto-run OCR on save
                        </label>
                    </div>
                </div>
            </div>
            
            <!-- API Settings Section -->
            <div class="form-group">
                <label style="font-weight: bold; margin-bottom: 10px; display: block;">API Configuration</label>
                <div>
                    <label for="settings-gemini-key">Gemini API Key:</label>
                    <input type="text" id="settings-gemini-key" style="width: 100%;" placeholder="Enter your Gemini API key">
                </div>
            </div>
            
            <!-- Import/Export Section -->
            <div class="form-group" style="border-top: 1px solid #ddd; padding-top: 15px;">
                <label style="font-weight: bold; margin-bottom: 10px; display: block;">Settings Management</label>
                <div style="display: flex; gap: 10px; justify-content: space-between;">
                    <button class="btn" onclick="exportSettings()">📥 Export Settings</button>
                    <input type="file" id="import-settings-file" accept=".json" style="display: none;" onchange="importSettings(this.files[0])">
                    <button class="btn" onclick="document.getElementById('import-settings-file').click()">📤 Import Settings</button>
                    <button class="btn-secondary" onclick="resetSettings()">🔄 Reset to Defaults</button>
                </div>
            </div>
            
            <div class="modal-buttons">
                <button class="btn-secondary" onclick="closeSettingsModal()">Cancel</button>
                <button class="btn" onclick="saveSettings()">Save Settings</button>
            </div>
        </div>
    </div>
    
    <!-- Progress Modal for Import Operations -->
    <div id="progress-modal" class="modal">
        <div class="modal-content" style="width: 400px;">
            <h3 id="progress-title">Processing...</h3>
            <div class="progress-container">
                <div class="progress-bar">
                    <div id="progress-fill" class="progress-fill"></div>
                </div>
                <div id="progress-text" class="progress-text">Initializing...</div>
            </div>
            <div class="progress-spinner">
                <div class="spinner"></div>
            </div>
        </div>
    </div>

    <!-- Bulk Edit Modal - REMOVED (multi-selection feature removed) -->
    <!-- Keeping Manage All Modal below for mass editing all extractions -->
    
    <!-- Manage All Modal -->
    <div id="manage-all-modal" class="modal">
        <div class="modal-content" style="width: 90%; max-width: 1000px;">
            <span class="close" onclick="closeManageAllModal()">&times;</span>
            <h3>Manage All Extractions</h3>
            <div style="margin: 15px 0;">
                <button class="btn" onclick="saveManageAllChanges()" style="background: #27ae60;">Save Changes</button>
                <button class="btn-secondary" onclick="closeManageAllModal()">Cancel</button>
                <span id="manage-all-status" style="margin-left: 15px; color: #666;"></span>
            </div>
            <div style="overflow-x: auto;">
                <table id="manage-all-table" style="width: 100%; border-collapse: collapse;">
                    <thead>
                        <tr style="background: #f0f0f0; border-bottom: 2px solid #ddd;">
                            <th style="padding: 10px; text-align: left;">Name</th>
                            <th style="padding: 10px; text-align: left; width: 150px;">Equipment Type</th>
                            <th style="padding: 10px; text-align: center; width: 60px;">Page</th>
                            <th style="padding: 10px; text-align: center; width: 80px;">OCR</th>
                            <th style="padding: 10px; text-align: center; width: 60px;">RFQ</th>
                        </tr>
                    </thead>
                    <tbody id="manage-all-tbody">
                        <!-- Rows will be populated here -->
                    </tbody>
                </table>
            </div>
        </div>
    </div>
    
    <!-- OCR Results Modal -->
    <div id="ocr-results-modal" class="modal">
        <div class="modal-content" style="width: 800px;">
            <span class="close" onclick="closeOCRResultsModal()">&times;</span>
            <h3 id="ocr-results-title">OCR Results</h3>
            
            <!-- Toggle between markdown and formatted table -->
            <div style="margin-bottom: 15px;">
                <label style="display: flex; align-items: center; gap: 10px;">
                    <input type="checkbox" id="ocr-format-toggle" style="margin: 0;">
                    <span>Show as formatted table (uncheck for raw markdown)</span>
                </label>
            </div>
            
            <!-- OCR Content Display -->
            <div id="ocr-content-display" style="background: #f8f9fa; border: 1px solid #dee2e6; border-radius: 4px; padding: 15px; max-height: 400px; overflow-y: auto; font-family: monospace; font-size: 12px; line-height: 1.4; white-space: pre-wrap; user-select: text; -webkit-user-select: text; -moz-user-select: text; -ms-user-select: text;">
                <!-- OCR results will be displayed here -->
            </div>
            
            <!-- Installation Notes Section -->
            <div id="ocr-notes-section" style="display: none; margin-top: 15px;">
                <h4 style="margin-bottom: 10px; color: #2c3e50;">Installation Notes & Requirements</h4>
                <div id="ocr-notes-content" style="background: #fff3cd; border: 1px solid #ffeaa7; border-radius: 4px; padding: 15px; max-height: 200px; overflow-y: auto; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; font-size: 13px; line-height: 1.5; user-select: text; -webkit-user-select: text; -moz-user-select: text; -ms-user-select: text;">
                    <!-- Notes will be displayed here -->
                </div>
            </div>
            
            <!-- OCR Metadata -->
            <div id="ocr-metadata" style="margin-top: 15px; padding: 10px; background: #e9ecef; border-radius: 4px; font-size: 11px; color: #6c757d;">
                <!-- OCR provider and confidence info -->
            </div>
            
            <div class="modal-buttons">
                <button class="btn-secondary" id="ocr-modal-close">Close</button>
            </div>
        </div>
    </div>

    <script>
        // Initialize PDF.js
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';

        // Application state
        let currentPDF = null;
        let currentPDFData = null; // Store original PDF data for annotation
        let currentPDFFile = null; // Store the File object for session management
        let currentPDFPath = null; // Store the actual file path when available
        let serverAvailable = false; // Track if Flask server is available
        let currentPage = 1;
        let totalPages = 0;
        let canvas = null;
        let ctx = null;
        
        // BlueBeam Spaces Manager
        let spaceManager = null;
        let isSelecting = false;
        let startX = 0;
        let startY = 0;
        let currentSelection = null;
        let currentOCRResult = null; // Store the latest OCR result for saving
        let isModalOpen = false; // Track modal state
        let extractions = [];
        let extractionCounter = 0;
        
        // Generate unique extraction ID
        function generateExtractionUID() {
            // Use timestamp + random for uniqueness
            const timestamp = Date.now();
            const random = Math.random().toString(36).substr(2, 9);
            return `ext_${timestamp}_${random}`;
        }
        
        // Simple OCR queue management
        function clearAllOCRResults() {
            currentOCRResult = null;
            console.log('OCR results cleared');
        }
        
        // Extract page text content asynchronously to avoid blocking page render
        async function extractPageTextAsync(page, pageNum) {
            try {
                console.time(`Page ${pageNum} Text Extraction (Async)`);
                setStatus(`Extracting text content for page ${pageNum}...`);
                
                const textContent = await page.getTextContent();
                
                // Only update if we're still on the same page
                if (currentPage === pageNum) {
                    currentPageTextContent = textContent;
                    console.log(`Page ${pageNum} text items extracted:`, textContent?.items?.length || 0);
                    setStatus(`Page ${pageNum} ready. Text extraction complete.`);
                } else {
                    console.log(`Page ${pageNum} text extraction completed but page changed`);
                }
                
                console.timeEnd(`Page ${pageNum} Text Extraction (Async)`);
            } catch (error) {
                console.error(`Error extracting text content for page ${pageNum}:`, error);
                if (currentPage === pageNum) {
                    currentPageTextContent = null;
                    setStatus(`Page ${pageNum} rendered. Text extraction failed.`);
                }
            }
        }
        
        // Simple OCR management
        function processPendingOCR() {
            // No longer needed - OCR is immediate
        }
        let selectedExtractionId = null;
        let editingExtractionId = null; // Track which extraction is being edited
        let currentExtractionUID = null; // Track current extraction UID for OCR isolation
        let enableTextExtraction = true; // Setting to enable/disable text extraction for performance
        let currentZoom = 1.0;
        const zoomLevels = [0.25, 0.5, 0.75, 1.0, 1.25, 1.5, 2.0, 3.0];
        let currentZoomIndex = 3;
        let currentPageTextContent = null;
        let currentPDFPageHeight = 0;
        let currentRenderOperation = null;
        let renderDebounceTimer = null;

        // DOM elements - will be initialized after DOM is loaded
        let pdfInput, canvasContainer, pdfCanvas, savedOverlay, tempOverlay;
        let loading, statusText, extractionList, modal, prevPageBtn, nextPageBtn;
        let currentPageSpan, totalPagesSpan;
        let clearSelectionsBtn, exportDataBtn, extractAllBtn;
        let zoomInBtn, zoomOutBtn, zoomLevelSpan;

        // BlueBeam Spaces Functions
        async function detectBlueBeamSpaces() {
            if (!currentPDF) {
                alert('Please load a PDF first');
                return;
            }
            
            setStatus('Detecting BlueBeam Spaces...');
            
            try {
                // Use the current PDF file if available
                const pdfFile = pdfInput.files[0];
                const result = await spaceManager.detectSpaces(pdfFile);
                
                // Update UI
                const spacesSection = document.getElementById('spaces-section');
                const spacesList = document.getElementById('spaces-list');
                const spacesCount = document.getElementById('spaces-count');
                const toggleBtn = document.getElementById('toggle-spaces');
                
                if (result.total_spaces > 0) {
                    spacesSection.style.display = 'block';
                    toggleBtn.style.display = 'inline-block';
                    document.getElementById('import-all-spaces').style.display = 'inline-block';
                    spacesCount.textContent = `${result.total_spaces} space${result.total_spaces !== 1 ? 's' : ''}`;
                    
                    // Update spaces list
                    updateSpacesList(result.spaces);
                    
                    // Render spaces for current page
                    const pageInfo = result.pages[currentPage - 1];
                    const pageHeight = pageInfo?.height || 792;
                    const pageWidth = pageInfo?.width || 612;
                    const rotation = pageInfo?.rotation || 0;
                    spaceManager.renderSpacesForPage(currentPage - 1, currentZoom, pageHeight, pageWidth, rotation);
                    
                    setStatus(`Detected ${result.total_spaces} BlueBeam Space${result.total_spaces !== 1 ? 's' : ''}`);
                } else {
                    setStatus('No BlueBeam Spaces found in this PDF');
                }
            } catch (error) {
                console.error('Error detecting spaces:', error);
                setStatus('Error detecting spaces: ' + error.message);
            }
        }
        
        function updateSpacesList(spaces) {
            const spacesList = document.getElementById('spaces-list');
            
            if (!spaces || spaces.length === 0) {
                spacesList.innerHTML = '<p style="color: #7f8c8d; font-style: italic;">No spaces detected</p>';
                return;
            }
            
            // Group spaces by page
            const spacesByPage = {};
            spaces.forEach(space => {
                const pageNum = space.page_number;
                if (!spacesByPage[pageNum]) {
                    spacesByPage[pageNum] = [];
                }
                spacesByPage[pageNum].push(space);
            });
            
            // Create HTML for spaces list
            let html = '';
            Object.keys(spacesByPage).sort((a, b) => parseInt(a) - parseInt(b)).forEach(pageNum => {
                const pageSpaces = spacesByPage[pageNum];
                html += `<div style="margin-bottom: 15px;">`;
                html += `<div style="font-weight: bold; color: #ecf0f1; margin-bottom: 5px;">Page ${parseInt(pageNum) + 1}</div>`;
                
                pageSpaces.forEach(space => {
                    const r = Math.round(space.color[0] * 255);
                    const g = Math.round(space.color[1] * 255);
                    const b = Math.round(space.color[2] * 255);
                    
                    html += `
                        <div class="space-item" data-space-id="${space.xref}" data-page="${space.page_number}" 
                             style="padding: 8px; margin: 5px 0; background: #34495e; border-radius: 4px; cursor: pointer;">
                            <div style="display: flex; align-items: center; gap: 10px;">
                                <div style="width: 20px; height: 20px; background: rgb(${r}, ${g}, ${b}); 
                                            opacity: ${space.opacity}; border-radius: 3px;"></div>
                                <div style="flex: 1;">
                                    <div style="font-size: 14px; color: #ecf0f1;">${space.title}</div>
                                    <div style="font-size: 11px; color: #95a5a6;">
                                        Area: ${Math.round(space.area)} sq pts
                                    </div>
                                </div>
                            </div>
                        </div>
                    `;
                });
                
                html += `</div>`;
            });
            
            spacesList.innerHTML = html;
            
            // Add click handlers to space items
            spacesList.querySelectorAll('.space-item').forEach(item => {
                item.addEventListener('click', function() {
                    const spaceId = parseInt(this.dataset.spaceId);
                    const pageNum = parseInt(this.dataset.page);
                    goToSpacePage(pageNum);
                });
            });
        }
        
        function goToSpacePage(pageNum) {
            if (currentPage !== pageNum + 1) {
                currentPage = pageNum + 1;
                updatePageInfo();
                renderPage(currentPage).then(() => {
                    // Re-render spaces after page change
                    if (spaceManager && spaceManager.getAllSpaces().length > 0) {
                        const pageInfo = spaceManager.pageInfo[pageNum];
                        const pageHeight = pageInfo?.height || 792;
                        const pageWidth = pageInfo?.width || 612;
                        const rotation = pageInfo?.rotation || 0;
                        spaceManager.renderSpacesForPage(pageNum, currentZoom, pageHeight, pageWidth, rotation);
                    }
                });
            }
        }
        
        function toggleSpacesVisibility() {
            const toggleBtn = document.getElementById('toggle-spaces');
            const isVisible = toggleBtn.textContent.includes('Hide');
            
            spaceManager.setSpacesVisible(!isVisible);
            toggleBtn.innerHTML = isVisible ? '👁️ Show Spaces' : '👁️ Hide Spaces';
        }
        
        function handleSpaceClick(event) {
            const space = event.detail;
            console.log('Space clicked:', space);
            convertSpaceToExtraction(space);
        }
        
        // Convert a BlueBeam space to an extraction
        async function convertSpaceToExtraction(space) {
            if (!space || !space.pymupdf_rect) {
                console.error('Invalid space data:', space);
                return;
            }
            
            // Convert pymupdf_rect to extraction coordinates
            // pymupdf_rect is [x0, y0, x1, y1] in PDF points
            const rect = space.pymupdf_rect;
            // Use page_number from space object (0-indexed) and convert to 1-indexed
            const pageNum = (space.page_number !== undefined ? space.page_number : 0) + 1;
            
            // Get page rotation info
            const pageInfo = spaceManager.pageInfo && spaceManager.pageInfo[space.page_number];
            const rotation = pageInfo?.rotation || 0;
            const pageWidth = pageInfo?.width || 612;
            const pageHeight = pageInfo?.height || 792;
            
            console.log('Converting space to extraction:', {
                spaceTitle: space.title,
                spacePage: space.page_number,
                extractionPage: pageNum,
                rect: rect,
                rotation: rotation,
                pageSize: { width: pageWidth, height: pageHeight }
            });
            
            // Apply rotation transformation if needed
            let x0 = rect[0];
            let y0 = rect[1];
            let x1 = rect[2];
            let y1 = rect[3];
            
            if (rotation === 90) {
                // For 90° rotation: swap X and Y coordinates
                const tempX0 = y0;
                const tempY0 = x0;
                const tempX1 = y1;
                const tempY1 = x1;
                
                x0 = tempX0;
                y0 = tempY0;
                x1 = tempX1;
                y1 = tempY1;
            } else if (rotation === 180) {
                // For 180° rotation: invert both X and Y
                const tempX0 = pageWidth - x1;
                const tempY0 = pageHeight - y1;
                const tempX1 = pageWidth - x0;
                const tempY1 = pageHeight - y0;
                
                x0 = tempX0;
                y0 = tempY0;
                x1 = tempX1;
                y1 = tempY1;
            } else if (rotation === 270) {
                // For 270° rotation: swap and invert appropriately
                const tempX0 = pageHeight - y1;
                const tempY0 = x1;
                const tempX1 = pageHeight - y0;
                const tempY1 = x0;
                
                x0 = tempX0;
                y0 = tempY0;
                x1 = tempX1;
                y1 = tempY1;
            }
            
            // Convert to extraction coordinate format (normalized to PDF scale 1.0)
            // The coordinates need to match what the selection system uses
            const selection = {
                page: pageNum,
                x: Math.min(x0, x1),
                y: Math.min(y0, y1), 
                width: Math.abs(x1 - x0),
                height: Math.abs(y1 - y0)
            };
            
            // Store the selection for the modal with space reference
            currentSelection = selection;
            currentSelection.spaceXref = space.xref; // Store space reference for later
            
            // Pre-populate modal fields with space data
            const modal = document.getElementById('schedule-modal');
            document.getElementById('extraction-name').value = space.title || 'BlueBeam Space';
            
            // Try to detect equipment type from title
            const equipmentType = detectEquipmentTypeFromTitle(space.title);
            document.getElementById('equipment-type').value = equipmentType;
            
            // Set extraction type based on space content (default to 'schedule' for BlueBeam spaces)
            const extractionType = detectExtractionTypeFromTitle(space.title, true);
            document.getElementById('extraction-type').value = extractionType;
            
            // Add description if available
            const description = space.subject || space.content || '';
            document.getElementById('extraction-description').value = description;
            
            // Default RFQ to false
            document.getElementById('rfq-required').checked = false;
            
            // Show the modal
            modal.style.display = 'flex';
            document.getElementById('extraction-name').focus();
            
            setStatus(`Converting BlueBeam Space "${space.title}" to extraction...`);
        }
        
        // Helper function to detect equipment type from title
        function detectEquipmentTypeFromTitle(title) {
            if (!title) return 'OTHER';
            
            const titleUpper = title.toUpperCase();
            
            // Check for equipment type keywords
            if (titleUpper.includes('FAN') || titleUpper.includes('EF-') || titleUpper.includes('SF-')) {
                return 'FANS';
            } else if (titleUpper.includes('VAV') || titleUpper.includes('TERMINAL')) {
                return 'VAV';
            } else if (titleUpper.includes('GRD') || titleUpper.includes('GRILLE') || titleUpper.includes('DIFFUSER')) {
                return 'GRD';
            } else if (titleUpper.includes('RTU') || titleUpper.includes('ROOFTOP')) {
                return 'RTU';
            } else if (titleUpper.includes('AHU') || titleUpper.includes('AIR HANDLING')) {
                return 'AHU';
            } else if (titleUpper.includes('DUCT') || titleUpper.includes('DUCTING')) {
                return 'DUCTING';
            }
            
            return 'OTHER';
        }
        
        // Helper function to detect extraction type from title (defaults to schedule for BlueBeam spaces)
        function detectExtractionTypeFromTitle(title, isBlueBeamSpace = false) {
            // Default to 'schedule' for BlueBeam spaces
            if (!title) return isBlueBeamSpace ? 'schedule' : 'other';
            
            const titleUpper = title.toUpperCase();
            
            if (titleUpper.includes('SCHEDULE')) {
                return 'schedule';
            } else if (titleUpper.includes('DRAWING') || titleUpper.includes('PLAN')) {
                return 'drawing';
            } else if (titleUpper.includes('TABLE')) {
                return 'table';
            } else if (titleUpper.includes('DETAIL')) {
                return 'detail';
            } else if (titleUpper.includes('SPEC')) {
                return 'specification';
            }
            
            // Default to 'schedule' for BlueBeam spaces, 'other' for regular extractions
            return isBlueBeamSpace ? 'schedule' : 'other';
        }
        
        // Import all detected BlueBeam spaces as extractions
        async function importAllSpaces() {
            if (!spaceManager || !spaceManager.spaces || spaceManager.spaces.length === 0) {
                alert('No BlueBeam spaces detected. Please detect spaces first.');
                return;
            }
            
            const totalSpaces = spaceManager.spaces.length;
            const confirm = window.confirm(`Import all ${totalSpaces} BlueBeam spaces as extractions?\n\nThis will create ${totalSpaces} new extraction items.`);
            
            if (!confirm) return;
            
            // Show progress modal
            const progressModal = document.getElementById('progress-modal');
            const progressTitle = document.getElementById('progress-title');
            const progressFill = document.getElementById('progress-fill');
            const progressText = document.getElementById('progress-text');
            
            progressModal.style.display = 'flex';
            progressTitle.textContent = `Importing ${totalSpaces} BlueBeam Spaces`;
            progressFill.style.width = '0%';
            progressText.textContent = `Processing space 0 of ${totalSpaces}...`;
            
            setStatus(`Importing ${totalSpaces} BlueBeam spaces...`);
            let imported = 0;
            let failed = 0;
            
            for (let i = 0; i < spaceManager.spaces.length; i++) {
                const space = spaceManager.spaces[i];
                
                // Update progress
                const progress = ((i + 1) / totalSpaces) * 100;
                progressFill.style.width = `${progress}%`;
                progressFill.textContent = `${Math.round(progress)}%`;
                progressText.textContent = `Processing "${space.title || 'Space ' + (i + 1)}" (${i + 1} of ${totalSpaces})...`;
                
                // Small delay to allow UI to update
                await new Promise(resolve => setTimeout(resolve, 10));
                
                try {
                    // Convert pymupdf_rect to extraction coordinates
                    const rect = space.pymupdf_rect;
                    // Use page_number from space object (0-indexed) and convert to 1-indexed
                    const pageNum = (space.page_number !== undefined ? space.page_number : 0) + 1;
                    
                    // Get page rotation info
                    const pageInfo = spaceManager.pageInfo && spaceManager.pageInfo[space.page_number];
                    const rotation = pageInfo?.rotation || 0;
                    
                    console.log(`Importing space "${space.title}" from page ${space.page_number} (extraction page ${pageNum}, rotation: ${rotation}°)`);
                    
                    // Apply rotation transformation if needed
                    let x0 = rect[0];
                    let y0 = rect[1];
                    let x1 = rect[2];
                    let y1 = rect[3];
                    
                    const pageWidth = pageInfo?.width || 612;
                    const pageHeight = pageInfo?.height || 792;
                    
                    if (rotation === 90) {
                        // For 90° rotation: swap X and Y coordinates
                        const tempX0 = y0;
                        const tempY0 = x0;
                        const tempX1 = y1;
                        const tempY1 = x1;
                        
                        x0 = tempX0;
                        y0 = tempY0;
                        x1 = tempX1;
                        y1 = tempY1;
                    } else if (rotation === 180) {
                        // For 180° rotation: invert both X and Y
                        const tempX0 = pageWidth - x1;
                        const tempY0 = pageHeight - y1;
                        const tempX1 = pageWidth - x0;
                        const tempY1 = pageHeight - y0;
                        
                        x0 = tempX0;
                        y0 = tempY0;
                        x1 = tempX1;
                        y1 = tempY1;
                    } else if (rotation === 270) {
                        // For 270° rotation: swap and invert appropriately
                        const tempX0 = pageHeight - y1;
                        const tempY0 = x1;
                        const tempX1 = pageHeight - y0;
                        const tempY1 = x0;
                        
                        x0 = tempX0;
                        y0 = tempY0;
                        x1 = tempX1;
                        y1 = tempY1;
                    }
                    
                    const selection = {
                        page: pageNum,
                        x: Math.min(x0, x1),
                        y: Math.min(y0, y1),
                        width: Math.abs(x1 - x0),
                        height: Math.abs(y1 - y0)
                    };
                    
                    // Create extraction object WITHOUT extracting image (for performance)
                    // Image will be extracted on-demand when needed
                    const extraction = {
                        id: generateExtractionUID(),
                        legacyId: ++extractionCounter,
                        extractionName: space.title || `BlueBeam Space ${imported + 1}`,
                        equipmentType: detectEquipmentTypeFromTitle(space.title),
                        extractionType: detectExtractionTypeFromTitle(space.title, true), // Pass true for BlueBeam spaces
                        description: space.subject || space.content || '',
                        rfqRequired: false,
                        coordinates: selection,
                        imageData: null, // Defer image extraction for performance
                        ocrData: null,
                        ocrStatus: 'none',
                        timestamp: new Date().toISOString(),
                        isBlueBeamSpace: true,
                        spaceXref: space.xref,
                        needsImageExtraction: true // Flag to indicate image needs extraction
                    };
                    
                    extractions.push(extraction);
                    imported++;
                    
                    // Mark space as imported in the space manager
                    if (spaceManager.importedSpaces) {
                        spaceManager.importedSpaces.add(space.xref);
                    } else {
                        spaceManager.importedSpaces = new Set([space.xref]);
                    }
                    
                } catch (error) {
                    console.error(`Failed to import space "${space.title}":`, error);
                    failed++;
                }
            }
            
            // Update UI
            updateExtractionList();
            saveToLocalStorage();
            restoreSelectionsForPage(currentPage);
            
            // Update space overlays to show imported status
            if (spaceManager && spaceManager.currentPageNum) {
                spaceManager.renderSpacesForPage(
                    spaceManager.currentPageNum - 1,
                    currentZoom,
                    spaceManager.pageHeight,
                    spaceManager.pageWidth,
                    0
                );
            }
            
            // Hide progress modal
            progressModal.style.display = 'none';
            
            const message = failed > 0 
                ? `Imported ${imported} spaces successfully. ${failed} failed.`
                : `Successfully imported all ${imported} BlueBeam spaces!`;
            
            setStatus(message);
            
            // Enable export button if we have extractions
            if (extractions.length > 0) {
                exportDataBtn.disabled = false;
                extractAllBtn.disabled = false;
            }
        }
        
        // Settings Management Functions
        async function initializeSettings() {
            try {
                // Initialize settings manager
                await window.settingsManager.init();
                
                // Apply settings to UI
                window.settingsManager.applySettingsToUI();
                
                // Load API key if saved
                const savedApiKey = window.settingsManager.getSetting('apiSettings.geminiApiKey');
                if (savedApiKey) {
                    const apiKeyInput = document.getElementById('gemini-api-key');
                    if (apiKeyInput) apiKeyInput.value = savedApiKey;
                }
                
                console.log('Settings initialized successfully');
            } catch (error) {
                console.error('Failed to initialize settings:', error);
            }
        }
        
        function openSettingsModal() {
            const modal = document.getElementById('settings-modal');
            if (!modal) return;
            
            // Populate settings UI
            populateSettingsModal();
            
            // Show modal
            modal.style.display = 'flex';
        }
        
        function closeSettingsModal() {
            const modal = document.getElementById('settings-modal');
            if (modal) modal.style.display = 'none';
        }
        
        function populateSettingsModal() {
            const settings = window.settingsManager.getSettings();
            
            // Populate equipment types
            const equipmentList = document.getElementById('equipment-types-list');
            equipmentList.innerHTML = '';
            settings.equipmentTypes.forEach(type => {
                const item = document.createElement('div');
                item.style.cssText = 'display: flex; justify-content: space-between; align-items: center; padding: 5px; margin: 2px 0; background: #f0f0f0;';
                item.innerHTML = `
                    <span>${type.label} (${type.value})</span>
                    <button class="btn-secondary" onclick="removeEquipmentType('${type.value}')" style="padding: 2px 8px; font-size: 12px;">Remove</button>
                `;
                equipmentList.appendChild(item);
            });
            
            // Populate search presets
            const searchList = document.getElementById('search-presets-list');
            searchList.innerHTML = '';
            settings.searchPresets.forEach(preset => {
                const item = document.createElement('div');
                item.style.cssText = 'display: inline-block; padding: 5px 10px; margin: 3px; background: #e0e0e0; border-radius: 3px;';
                item.innerHTML = `
                    ${preset}
                    <button onclick="removeSearchPreset('${preset}')" style="margin-left: 5px; border: none; background: none; color: red; cursor: pointer;">✕</button>
                `;
                searchList.appendChild(item);
            });
            
            // Populate default selects
            const defaultEquipment = document.getElementById('default-equipment-type');
            defaultEquipment.innerHTML = '';
            settings.equipmentTypes.forEach(type => {
                const option = document.createElement('option');
                option.value = type.value;
                option.textContent = type.label;
                defaultEquipment.appendChild(option);
            });
            defaultEquipment.value = settings.defaultSettings.defaultEquipmentType;
            
            const defaultExtraction = document.getElementById('default-extraction-type');
            defaultExtraction.innerHTML = '';
            settings.extractionTypes.forEach(type => {
                const option = document.createElement('option');
                option.value = type.value;
                option.textContent = type.label;
                defaultExtraction.appendChild(option);
            });
            defaultExtraction.value = settings.defaultSettings.defaultExtractionType;
            
            // Set other defaults
            document.getElementById('default-ocr-provider').value = settings.defaultSettings.ocrProvider;
            document.getElementById('default-auto-ocr').checked = settings.defaultSettings.autoRunOCR;
            
            // Set API key
            const apiKey = localStorage.getItem('gemini-api-key') || '';
            document.getElementById('settings-gemini-key').value = apiKey;
        }
        
        function addEquipmentType() {
            const valueInput = document.getElementById('new-equipment-value');
            const labelInput = document.getElementById('new-equipment-label');
            
            const value = valueInput.value.trim().toUpperCase();
            const label = labelInput.value.trim() || value;
            
            if (!value) {
                alert('Please enter an equipment type value');
                return;
            }
            
            if (window.settingsManager.addEquipmentType(value, label)) {
                valueInput.value = '';
                labelInput.value = '';
                populateSettingsModal();
            }
        }
        
        function removeEquipmentType(value) {
            if (confirm(`Remove equipment type "${value}"?`)) {
                window.settingsManager.removeEquipmentType(value);
                populateSettingsModal();
            }
        }
        
        function addSearchPreset() {
            const input = document.getElementById('new-search-preset');
            const preset = input.value.trim().toUpperCase();
            
            if (!preset) return;
            
            if (window.settingsManager.addSearchPreset(preset)) {
                input.value = '';
                populateSettingsModal();
            }
        }
        
        function removeSearchPreset(preset) {
            window.settingsManager.removeSearchPreset(preset);
            populateSettingsModal();
        }
        
        function saveSettings() {
            // Save default settings
            const defaultSettings = {
                defaultEquipmentType: document.getElementById('default-equipment-type').value,
                defaultExtractionType: document.getElementById('default-extraction-type').value,
                ocrProvider: document.getElementById('default-ocr-provider').value,
                autoRunOCR: document.getElementById('default-auto-ocr').checked
            };
            
            window.settingsManager.saveUserSettings({ defaultSettings });
            
            // Save API key
            const apiKey = document.getElementById('settings-gemini-key').value;
            if (apiKey) {
                localStorage.setItem('gemini-api-key', apiKey);
                // Also update the main OCR config input
                const mainApiInput = document.getElementById('gemini-api-key');
                if (mainApiInput) mainApiInput.value = apiKey;
            }
            
            // Apply settings to UI
            window.settingsManager.applySettingsToUI();
            
            // Close modal
            closeSettingsModal();
            
            setStatus('Settings saved successfully');
        }
        
        function exportSettings() {
            window.settingsManager.exportSettings();
        }
        
        async function importSettings(file) {
            if (!file) return;
            
            if (await window.settingsManager.importSettings(file)) {
                populateSettingsModal();
                window.settingsManager.applySettingsToUI();
                setStatus('Settings imported successfully');
            }
        }
        
        function resetSettings() {
            if (confirm('Reset all settings to defaults? This cannot be undone.')) {
                window.settingsManager.resetToDefaults();
                populateSettingsModal();
                window.settingsManager.applySettingsToUI();
                setStatus('Settings reset to defaults');
            }
        }
        
        // Initialize
        document.addEventListener('DOMContentLoaded', async function() {
            // Check server status immediately and periodically
            await checkServerStatus();
            setInterval(checkServerStatus, 30000); // Check every 30 seconds
            
            // Initialize Settings Manager
            await initializeSettings();
            
            // Initialize DOM elements
            pdfInput = document.getElementById('pdf-input');
            canvasContainer = document.getElementById('canvas-container');
            pdfCanvas = document.getElementById('pdf-canvas');
            savedOverlay = document.getElementById('saved-overlay');
            tempOverlay = document.getElementById('temp-overlay');
            loading = document.getElementById('loading');
            statusText = document.getElementById('status-text');
            extractionList = document.getElementById('extraction-list');
            modal = document.getElementById('schedule-modal');
            prevPageBtn = document.getElementById('prev-page');
            nextPageBtn = document.getElementById('next-page');
            currentPageSpan = document.getElementById('current-page');
            totalPagesSpan = document.getElementById('total-pages');
            clearSelectionsBtn = document.getElementById('clear-selections');
            exportDataBtn = document.getElementById('export-data');
            extractAllBtn = document.getElementById('extract-all');
            zoomInBtn = document.getElementById('zoom-in');
            zoomOutBtn = document.getElementById('zoom-out');
            zoomLevelSpan = document.getElementById('zoom-level');
            
            canvas = pdfCanvas;
            ctx = canvas.getContext('2d');
            
            // Initialize BlueBeam Space Manager
            spaceManager = new BlueBeamSpaceManager();
            spaceManager.init();
            
            setupEventListeners();
        });

        function setupEventListeners() {
            pdfInput.addEventListener('change', handleFileSelect);
            canvas.addEventListener('mousedown', startSelection);
            canvas.addEventListener('mousemove', updateSelection);
            canvas.addEventListener('mouseup', endSelection);
            prevPageBtn.addEventListener('click', () => changePage(-1));
            nextPageBtn.addEventListener('click', () => changePage(1));
            clearSelectionsBtn.addEventListener('click', clearAllSelections);
            document.getElementById('delete-all-extractions').addEventListener('click', deleteAllExtractions);
            exportDataBtn.addEventListener('click', exportExtractions);
            document.getElementById('export-local').addEventListener('click', exportToLocalDirectory);
            extractAllBtn.addEventListener('click', extractAllImages);
            zoomInBtn.addEventListener('click', zoomIn);
            zoomOutBtn.addEventListener('click', zoomOut);
            
            const manageAllBtn = document.getElementById('manage-all');
            if (manageAllBtn) {
                manageAllBtn.addEventListener('click', openManageAllModal);
            }
            
            // Text extraction toggle
            document.getElementById('enable-text-extraction').addEventListener('change', function(e) {
                enableTextExtraction = e.target.checked;
                console.log('Text extraction', enableTextExtraction ? 'enabled' : 'disabled');
                
                // If we just enabled it and we're on a page without text content, extract it now
                if (enableTextExtraction && currentPDF && !currentPageTextContent) {
                    currentPDF.getPage(currentPage).then(page => {
                        extractPageTextAsync(page, currentPage);
                    });
                }
            });
            
            
            // Mouse wheel zoom
            canvas.addEventListener('wheel', handleMouseWheel, { passive: false });
            
            // BlueBeam Spaces buttons
            document.getElementById('detect-spaces').addEventListener('click', detectBlueBeamSpaces);
            document.getElementById('import-all-spaces').addEventListener('click', importAllSpaces);
            document.getElementById('toggle-spaces').addEventListener('click', toggleSpacesVisibility);
            
            // Settings button
            document.getElementById('open-settings').addEventListener('click', openSettingsModal);
            
            // Listen for space click events
            document.addEventListener('spaceClicked', handleSpaceClick);
            
            // Modal event listeners
            document.getElementById('modal-cancel').addEventListener('click', closeModal);
            document.getElementById('modal-save').addEventListener('click', saveSchedule);
            document.getElementById('enable-table-ocr').addEventListener('change', toggleTableOCR);
            
            // OCR Results Modal event listeners
            document.getElementById('ocr-modal-close').addEventListener('click', closeOCRResultsModal);
            document.getElementById('ocr-format-toggle').addEventListener('change', handleOCRFormatToggle);
            document.getElementById('equipment-type').addEventListener('change', handleEquipmentTypeChange);
            document.getElementById('extraction-type').addEventListener('change', handleExtractionTypeChange);
            document.getElementById('custom-equipment-type').addEventListener('input', handleCustomEquipmentTypeChange);
            document.getElementById('custom-equipment-type').addEventListener('change', handleCustomEquipmentTypeChange);
            
            // Add Enter key handler for modal
            modal.addEventListener('keydown', function(e) {
                if (e.key === 'Enter' && !e.shiftKey && !e.ctrlKey && !e.altKey) {
                    // Only trigger if we're not in the debug textarea and modal is visible
                    if (modal.style.display === 'block' && e.target.tagName !== 'TEXTAREA') {
                        e.preventDefault();
                        saveSchedule();
                    }
                }
            });
            
            // Close modal when clicking outside
            modal.addEventListener('click', function(e) {
                if (e.target === modal) {
                    closeModal();
                }
            });
            
            // Close OCR results modal when clicking outside
            const ocrModal = document.getElementById('ocr-results-modal');
            ocrModal.addEventListener('click', function(e) {
                if (e.target === ocrModal) {
                    closeOCRResultsModal();
                }
            });

            // Search functionality event listeners
            const searchInput = document.getElementById('search-input');
            const addSearchBtn = document.getElementById('add-search-btn');
            const searchBtn = document.getElementById('search-btn');

            if (searchInput) {
                searchInput.addEventListener('keypress', function(e) {
                    if (e.key === 'Enter') {
                        e.preventDefault();
                        addSearchTerm();
                    }
                });
            }

            if (addSearchBtn) {
                addSearchBtn.addEventListener('click', addSearchTerm);
            }

            if (searchBtn) {
                searchBtn.addEventListener('click', performTextSearch);
            }
        }

        async function handleFileSelect(event) {
            const file = event.target.files[0];
            if (!file) return;

            // Store file reference for session management
            currentPDFFile = file;
            
            // Clear BlueBeam Spaces from previous PDF
            if (spaceManager) {
                spaceManager.clearOverlays();
                spaceManager.spaces = [];
                spaceManager.pageSpaces = {};
                spaceManager.importedSpaces = new Set();
                spaceManager.pageInfo = {};
                
                // Hide spaces UI sections
                const spacesSection = document.getElementById('spaces-section');
                if (spacesSection) {
                    spacesSection.style.display = 'none';
                }
                const detectBtn = document.getElementById('detect-spaces');
                const importBtn = document.getElementById('import-all-spaces');
                const toggleBtn = document.getElementById('toggle-spaces');
                if (detectBtn) detectBtn.textContent = '🔍 Detect Spaces';
                if (importBtn) importBtn.style.display = 'none';
                if (toggleBtn) toggleBtn.style.display = 'none';
            }
            
            // Check for existing session
            const hasSession = hasExistingSession(file.name);
            let shouldLoadSession = false;
            
            if (hasSession) {
                const session = loadSessionFromLocalStorage(file.name);
                if (session) {
                    const timeSince = getTimeSinceLastModified(session.lastModified);
                    const message = `Found previous session for this PDF:\n` +
                                   `• ${session.extractions.length} extractions\n` +
                                   `• Last modified: ${timeSince}\n\n` +
                                   `Resume session?`;
                    
                    shouldLoadSession = confirm(message);
                    
                    if (!shouldLoadSession) {
                        // Ask if they want to clear the session
                        if (confirm('Clear the existing session data?')) {
                            clearSession(file.name);
                        }
                    }
                }
            }
            
            // Clear current extractions if loading a different PDF
            if (!shouldLoadSession) {
                resetExtractions();
            }

            console.time('PDF Loading Total');
            setStatus('Loading PDF...');
            loading.style.display = 'block';
            canvasContainer.style.display = 'none';

            try {
                console.time('PDF File Reading');
                const arrayBuffer = await file.arrayBuffer();
                console.timeEnd('PDF File Reading');
                
                console.time('PDF Document Parsing');
                currentPDFData = arrayBuffer.slice(); // Create a copy to prevent detachment
                currentPDF = await pdfjsLib.getDocument(arrayBuffer).promise;
                totalPages = currentPDF.numPages;
                currentPage = 1;
                console.timeEnd('PDF Document Parsing');
                
                console.time('Initial Page Render');
                updatePageInfo();
                await renderPage(currentPage);
                console.timeEnd('Initial Page Render');
                
                canvasContainer.style.display = 'block';
                loading.style.display = 'none';
                
                // Load session if requested
                if (shouldLoadSession) {
                    const session = loadSessionFromLocalStorage(file.name);
                    if (session) {
                        restoreSession(session);
                        setStatus(`PDF loaded with ${session.extractions.length} extractions from saved session`);
                        updateSessionStatus(`Session active (${session.extractions.length} extractions)`);
                    } else {
                        setStatus('PDF loaded successfully. Click and drag to select schedule areas.');
                        updateSessionStatus('New session');
                    }
                } else {
                    setStatus('PDF loaded successfully. Click and drag to select schedule areas.');
                    updateSessionStatus('New session');
                }
                
                console.timeEnd('PDF Loading Total');
                
                // Enable controls
                prevPageBtn.disabled = currentPage === 1;
                nextPageBtn.disabled = currentPage === totalPages;
                clearSelectionsBtn.disabled = false;
                exportDataBtn.disabled = false;
                extractAllBtn.disabled = extractions.length === 0;
                zoomInBtn.disabled = false;
                zoomOutBtn.disabled = false;
                updateZoomControls();
                
            } catch (error) {
                console.error('Error loading PDF:', error);
                setStatus('Error loading PDF. Please try again.');
                loading.innerHTML = 'Error loading PDF. Please select a valid PDF file.';
            }
        }

        async function renderPage(pageNum) {
            if (!currentPDF) return;

            console.time(`Page ${pageNum} Render Total`);

            // Cancel any existing render operation
            if (currentRenderOperation) {
                try {
                    await currentRenderOperation._transport.destroy();
                } catch (error) {
                    // Ignore cancellation errors
                }
            }

            setStatus(`Rendering page ${pageNum}...`);
            
            try {
                console.time(`Page ${pageNum} Get Page`);
                const page = await currentPDF.getPage(pageNum);
                console.timeEnd(`Page ${pageNum} Get Page`);
                
                console.time(`Page ${pageNum} Setup Canvas`);
                const viewport = page.getViewport({ scale: 1.5 * currentZoom });
                
                canvas.width = viewport.width;
                canvas.height = viewport.height;
                
                // Store PDF page height for coordinate conversions
                currentPDFPageHeight = viewport.height;
                
                // Clear temporary overlay only
                clearTempOverlay();
                
                console.timeEnd(`Page ${pageNum} Setup Canvas`);
                
                // Normal rendering
                const renderContext = {
                    canvasContext: ctx,
                    viewport: viewport,
                    renderInteractiveForms: false, // Don't render form fields
                    includeAnnotationStorage: false // Don't include annotations
                };
                
                console.time(`Page ${pageNum} PDF Render`);
                // Store current render operation
                currentRenderOperation = page.render(renderContext);
                await currentRenderOperation.promise;
                currentRenderOperation = null;
                console.timeEnd(`Page ${pageNum} PDF Render`);
                setStatus(`Page ${pageNum} rendered.`);
                
                // Extract text content asynchronously to avoid blocking page render (if enabled)
                currentPageTextContent = null; // Clear immediately
                if (enableTextExtraction) {
                    extractPageTextAsync(page, pageNum);
                } else {
                    setStatus(`Page ${pageNum} rendered. Text extraction disabled for performance.`);
                }
                
                console.time(`Page ${pageNum} Restore Selections`);
                // Restore selections for this page
                restoreSelectionsForPage(pageNum);
                console.timeEnd(`Page ${pageNum} Restore Selections`);
                
                // Render BlueBeam Spaces if they have been detected
                if (spaceManager && spaceManager.getAllSpaces().length > 0) {
                    const pageInfo = spaceManager.pageInfo[pageNum - 1];
                    const pageHeight = pageInfo?.height || viewport.height / (1.5 * currentZoom);
                    const pageWidth = pageInfo?.width || viewport.width / (1.5 * currentZoom);
                    const rotation = pageInfo?.rotation || 0;
                    spaceManager.renderSpacesForPage(pageNum - 1, currentZoom, pageHeight, pageWidth, rotation);
                }
                
                console.timeEnd(`Page ${pageNum} Render Total`);
                setStatus(`Page ${pageNum} rendered. Click and drag to select schedule areas.`);
                
            } catch (error) {
                if (error.name !== 'RenderingCancelledException') {
                    console.error('Error rendering page:', error);
                    setStatus('Error rendering page');
                }
                currentRenderOperation = null;
            }
        }

        function zoomIn() {
            if (currentZoomIndex < zoomLevels.length - 1) {
                currentZoomIndex++;
                currentZoom = zoomLevels[currentZoomIndex];
                updateZoomControls();
                // Clear overlays before re-rendering to prevent duplicates
                clearSavedOverlay();
                clearTempOverlay();
                debouncedRenderPage(currentPage);
            }
        }

        function zoomOut() {
            if (currentZoomIndex > 0) {
                currentZoomIndex--;
                currentZoom = zoomLevels[currentZoomIndex];
                updateZoomControls();
                // Clear overlays before re-rendering to prevent duplicates
                clearSavedOverlay();
                clearTempOverlay();
                debouncedRenderPage(currentPage);
            }
        }

        function debouncedRenderPage(pageNum) {
            // Clear any existing debounce timer
            if (renderDebounceTimer) {
                clearTimeout(renderDebounceTimer);
            }
            
            // Set a new debounce timer
            renderDebounceTimer = setTimeout(() => {
                renderPage(pageNum);
                renderDebounceTimer = null;
            }, 100); // 100ms debounce
        }

        function updateZoomControls() {
            zoomLevelSpan.textContent = Math.round(currentZoom * 100) + '%';
            zoomInBtn.disabled = currentZoomIndex >= zoomLevels.length - 1;
            zoomOutBtn.disabled = currentZoomIndex <= 0;
        }

        function handleMouseWheel(event) {
            // Check if Ctrl key is pressed (for zoom)
            if (event.ctrlKey) {
                event.preventDefault();
                if (event.deltaY < 0) {
                    // Scroll up - zoom in
                    zoomIn();
                } else {
                    // Scroll down - zoom out
                    zoomOut();
                }
            } else {
                // Normal scrolling for panning
                event.preventDefault();
                
                const scrollAmount = 50; // pixels per scroll increment
                const container = document.querySelector('.pdf-container');
                
                if (event.shiftKey) {
                    // Horizontal scrolling with Shift+scroll
                    container.scrollBy({
                        left: event.deltaY > 0 ? scrollAmount : -scrollAmount,
                        behavior: 'smooth'
                    });
                } else {
                    // Vertical scrolling
                    container.scrollBy({
                        top: event.deltaY > 0 ? scrollAmount : -scrollAmount,
                        behavior: 'smooth'
                    });
                }
            }
        }

        function changePage(direction) {
            const newPage = currentPage + direction;
            if (newPage >= 1 && newPage <= totalPages) {
                currentPage = newPage;
                updatePageInfo();
                // Clear overlays before changing pages
                clearSavedOverlay();
                clearTempOverlay();
                renderPage(currentPage);
            }
        }

        function updatePageInfo() {
            currentPageSpan.textContent = currentPage;
            totalPagesSpan.textContent = totalPages;
            prevPageBtn.disabled = currentPage === 1;
            nextPageBtn.disabled = currentPage === totalPages;
        }

        function startSelection(event) {
            const rect = canvas.getBoundingClientRect();
            // Store raw screen coordinates relative to canvas
            startX = event.clientX - rect.left;
            startY = event.clientY - rect.top;
            isSelecting = true;
            
            // Clear temporary overlay only
            clearTempOverlay();
        }

        function updateSelection(event) {
            if (!isSelecting) return;
            
            const rect = canvas.getBoundingClientRect();
            // Store raw screen coordinates relative to canvas
            const currentX = event.clientX - rect.left;
            const currentY = event.clientY - rect.top;
            
            clearTempOverlay();
            drawTempSelectionRect(startX, startY, currentX, currentY);
        }

        function endSelection(event) {
            if (!isSelecting) return;
            
            const rect = canvas.getBoundingClientRect();
            // Store raw screen coordinates relative to canvas
            const endX = event.clientX - rect.left;
            const endY = event.clientY - rect.top;
            
            isSelecting = false;
            
            // Calculate selection bounds in screen coordinates
            const screenX = Math.min(startX, endX);
            const screenY = Math.min(startY, endY);
            const screenWidth = Math.abs(endX - startX);
            const screenHeight = Math.abs(endY - startY);
            
            // Convert screen coordinates to PDF coordinates
            // Screen coordinates are at current display scale (1.5 * currentZoom)
            // We need to normalize to base PDF scale (1.0)
            const currentDisplayScale = 1.5 * currentZoom;
            
            // Convert to PDF coordinates (normalized to scale 1.0)
            const pdfX = screenX / currentDisplayScale;
            const pdfY = screenY / currentDisplayScale;
            const pdfWidth = screenWidth / currentDisplayScale;
            const pdfHeight = screenHeight / currentDisplayScale;
            
            console.log('Selection debug:', {
                currentZoom,
                currentDisplayScale,
                screenCoords: { screenX, screenY, screenWidth, screenHeight },
                pdfCoords: { pdfX, pdfY, pdfWidth, pdfHeight },
                canvasSize: { width: canvas.width, height: canvas.height }
            });
            
            // Only process if selection is meaningful (larger than 10x10 in screen coordinates)
            if (screenWidth > 10 && screenHeight > 10) {
                currentSelection = { x: pdfX, y: pdfY, width: pdfWidth, height: pdfHeight, page: currentPage };
                showScheduleModal();
            } else {
                clearTempOverlay();
            }
        }

        function drawTempSelectionRect(x1, y1, x2, y2) {
            const x = Math.min(x1, x2);
            const y = Math.min(y1, y2);
            const width = Math.abs(x2 - x1);
            const height = Math.abs(y2 - y1);
            
            const selectionRect = document.createElement('div');
            selectionRect.className = 'selection-rect';
            selectionRect.style.left = x + 'px';
            selectionRect.style.top = y + 'px';
            selectionRect.style.width = width + 'px';
            selectionRect.style.height = height + 'px';
            
            tempOverlay.appendChild(selectionRect);
        }

        function clearTempOverlay() {
            tempOverlay.innerHTML = '';
        }

        function clearSavedOverlay() {
            savedOverlay.innerHTML = '';
        }

        function showScheduleModal() {
            // Set modal state
            isModalOpen = true;
            
            // Initialize search text state
            initializeSearchText();
            
            // Clear any previous OCR data completely
            currentOCRResult = null;
            editingExtractionId = null; // Ensure we're not in editing mode
            
            // Clear ALL OCR UI elements thoroughly - use innerHTML to clear all content including HTML
            document.getElementById('table-ocr-status').innerHTML = '';
            document.getElementById('table-ocr-status').style.display = 'none';
            document.getElementById('ocr-config-group').style.display = 'none';
            document.getElementById('enable-table-ocr').checked = false;
            
            // Clear OCR preview container
            const previewContainer = document.getElementById('ocr-preview');
            if (previewContainer) {
                previewContainer.innerHTML = '';
            }
            
            // Try to auto-detect schedule information
            const detectedInfo = detectScheduleInfo();
            
            // Set the detected equipment type first
            document.getElementById('equipment-type').value = detectedInfo.type || 'FANS';
            document.getElementById('extraction-type').value = 'schedule'; // Default extraction type
            document.getElementById('extraction-description').value = detectedInfo.notes || '';
            document.getElementById('rfq-required').checked = false; // Default RFQ to unchecked
            
            // Generate auto name after setting the types
            generateExtractionName();
            
            modal.style.display = 'flex';
            document.getElementById('extraction-name').focus();
        }

        function detectScheduleInfo() {
            if (!currentPageTextContent || !currentSelection) {
                // If text content isn't ready yet, return defaults
                if (!currentPageTextContent) {
                    if (!enableTextExtraction) {
                        console.log('Text extraction disabled - auto-detection unavailable');
                    } else {
                        console.log('Text content not ready for auto-detection, using defaults');
                    }
                }
                return { name: '', type: 'FANS', notes: '' };
            }
            
            // Extract text items within or near the selection area
            const selectionText = extractTextFromSelection(currentSelection);
            
            // Try to detect schedule title
            const titleMatch = detectScheduleTitle(selectionText);
            
            // Try to detect equipment type
            const equipmentType = detectEquipmentType(selectionText);
            
            return {
                name: titleMatch || '',
                type: equipmentType || 'FANS',
                notes: ''
            };
        }

        function extractTextFromSelection(selection) {
            if (!currentPageTextContent) return '';
            
            const textItems = [];
            const scale = 1.5; // Base scale used in rendering
            
            currentPageTextContent.items.forEach(item => {
                const transform = item.transform;
                // PDF coordinates: transform[4] = x, transform[5] = y
                // PDF uses bottom-left origin, canvas uses top-left origin
                const pdfX = transform[4];
                const pdfY = transform[5];
                
                // Convert PDF coordinates to canvas coordinates
                // Note: PDF y-coordinates are from bottom, canvas y-coordinates are from top
                const canvasX = pdfX / scale;
                const canvasY = (canvas.height / (scale * currentZoom)) - (pdfY / scale);
                
                // Check if text is within or near the selection bounds (in original coordinates)
                const buffer = 30; // Allow some buffer around selection
                if (canvasX >= selection.x - buffer && 
                    canvasX <= selection.x + selection.width + buffer &&
                    canvasY >= selection.y - buffer && 
                    canvasY <= selection.y + selection.height + buffer) {
                    textItems.push({
                        text: item.str,
                        x: canvasX,
                        y: canvasY
                    });
                }
            });
            
            // Sort by y position (top to bottom) then x position (left to right)
            textItems.sort((a, b) => {
                if (Math.abs(a.y - b.y) < 10) { // Same line
                    return a.x - b.x;
                }
                return a.y - b.y;
            });
            
            return textItems.map(item => item.text).join(' ');
        }

        function detectScheduleTitle(text) {
            const titlePatterns = [
                /([A-Z\s]*SCHEDULE)/i,
                /(FAN\s*SCHEDULE)/i,
                /(VAV\s*SCHEDULE)/i,
                /(RTU\s*SCHEDULE)/i,
                /(GRILLE?\s*SCHEDULE)/i,
                /(DIFFUSER\s*SCHEDULE)/i,
                /(EQUIPMENT\s*SCHEDULE)/i
            ];
            
            for (const pattern of titlePatterns) {
                const match = text.match(pattern);
                if (match) {
                    return match[1].trim();
                }
            }
            
            return null;
        }

        function detectEquipmentType(text) {
            const typePatterns = [
                { pattern: /fan|exhaust|supply/i, type: 'FANS' },
                { pattern: /vav|variable\s*air\s*volume/i, type: 'VAV' },
                { pattern: /rtu|roof\s*top\s*unit/i, type: 'RTU' },
                { pattern: /grille|diffuser|grd/i, type: 'GRD' }
            ];
            
            for (const { pattern, type } of typePatterns) {
                if (pattern.test(text)) {
                    return type;
                }
            }
            
            return 'OTHER';
        }

        function toggleOCRDebug() {
            const debugDiv = document.getElementById('ocr-debug');
            const checkbox = document.getElementById('debug-ocr');
            
            if (checkbox.checked) {
                debugDiv.style.display = 'block';
                updateOCRDebugInfo();
            } else {
                debugDiv.style.display = 'none';
            }
        }

        function updateOCRDebugInfo() {
            const debugDiv = document.getElementById('ocr-debug');
            const checkbox = document.getElementById('debug-ocr');
            
            if (!checkbox.checked || !currentPageTextContent || !currentSelection) {
                return;
            }
            
            const selectionText = extractTextFromSelection(currentSelection);
            const detectedTitle = detectScheduleTitle(selectionText);
            const detectedType = detectEquipmentType(selectionText);
            
            let debugInfo = `=== OCR DEBUG INFO ===\n\n`;
            debugInfo += `Current zoom: ${currentZoom} (${Math.round(currentZoom * 100)}%)\n`;
            debugInfo += `Canvas size: ${canvas.width} x ${canvas.height}\n`;
            debugInfo += `Display scale: ${1.5 * currentZoom}\n\n`;
            debugInfo += `Selection coordinates: (${currentSelection.x.toFixed(1)}, ${currentSelection.y.toFixed(1)}) `;
            debugInfo += `${currentSelection.width.toFixed(1)}x${currentSelection.height.toFixed(1)}\n\n`;
            
            debugInfo += `Extracted text: "${selectionText}"\n\n`;
            debugInfo += `Detected title: "${detectedTitle || 'None'}"\n`;
            debugInfo += `Detected type: "${detectedType}"\n\n`;
            
            debugInfo += `=== ALL TEXT ITEMS IN SELECTION ===\n`;
            const textItems = getTextItemsInSelection(currentSelection);
            textItems.forEach((item, index) => {
                debugInfo += `${index + 1}. "${item.text}" at (${item.x.toFixed(1)}, ${item.y.toFixed(1)})\n`;
            });
            
            debugDiv.textContent = debugInfo;
        }

        function getTextItemsInSelection(selection) {
            if (!currentPageTextContent) return [];
            
            const textItems = [];
            const scale = 1.5;
            
            currentPageTextContent.items.forEach(item => {
                const transform = item.transform;
                const pdfX = transform[4];
                const pdfY = transform[5];
                
                const canvasX = pdfX / scale;
                const canvasY = (canvas.height / (scale * currentZoom)) - (pdfY / scale);
                
                const buffer = 30;
                if (canvasX >= selection.x - buffer && 
                    canvasX <= selection.x + selection.width + buffer &&
                    canvasY >= selection.y - buffer && 
                    canvasY <= selection.y + selection.height + buffer) {
                    textItems.push({
                        text: item.str,
                        x: canvasX,
                        y: canvasY
                    });
                }
            });
            
            return textItems.sort((a, b) => {
                if (Math.abs(a.y - b.y) < 10) {
                    return a.x - b.x;
                }
                return a.y - b.y;
            });
        }

        function toggleTableOCR() {
            const checkbox = document.getElementById('enable-table-ocr');
            const statusDiv = document.getElementById('table-ocr-status');
            const configGroup = document.getElementById('ocr-config-group');
            
            // Add null checks for DOM elements
            if (!checkbox || !statusDiv || !outputDiv || !configGroup) {
                console.error('OCR toggle failed: missing DOM elements');
                return;
            }
            
            if (checkbox.checked) {
                if (!window.OCRTableExtractor || !window.OCRTableExtractor.isSupported()) {
                    alert('OCR functionality not available. Please check that required libraries are loaded.');
                    checkbox.checked = false;
                    return;
                }
                
                statusDiv.style.display = 'block';
                outputDiv.style.display = 'block';
                configGroup.style.display = 'block';
                
                // Initialize OCR config
                initOCRConfig();
                
                // Run OCR immediately in modal
                processTableOCR();
            } else {
                statusDiv.style.display = 'none';
                outputDiv.style.display = 'none';
                configGroup.style.display = 'none';
                currentOCRResult = null; // Clear stored OCR result
            }
        }

        function initOCRConfig() {
            const providerSelect = document.getElementById('ocr-provider');
            const geminiConfig = document.getElementById('gemini-config');
            const providerStatus = document.getElementById('provider-status');
            const apiKeyInput = document.getElementById('gemini-api-key');
            
            // Add null checks
            if (!providerSelect || !geminiConfig || !providerStatus || !apiKeyInput) {
                console.error('OCR config init failed: missing DOM elements');
                return;
            }
            
            // Load saved API key
            const savedApiKey = localStorage.getItem('gemini-api-key');
            if (savedApiKey) {
                apiKeyInput.value = savedApiKey;
            }
            
            // Show/hide Gemini config based on provider selection
            function updateProviderUI() {
                const selectedProvider = providerSelect.value;
                
                if (selectedProvider === 'gemini') {
                    geminiConfig.style.display = 'block';
                } else {
                    geminiConfig.style.display = 'none';
                }
                
                // Update provider status
                updateProviderStatus();
            }
            
            function updateProviderStatus() {
                const providers = window.OCRTableExtractor.getAvailableProviders();
                let statusText = '';
                let statusClass = '';
                
                if (providers.length === 0) {
                    statusText = 'No OCR providers available';
                    statusClass = 'error';
                } else {
                    const providerNames = providers.map(p => p.name).join(', ');
                    statusText = `Available providers: ${providerNames}`;
                    statusClass = 'success';
                }
                
                providerStatus.textContent = statusText;
                providerStatus.className = statusClass;
                providerStatus.style.display = 'block';
                
                if (statusClass === 'error') {
                    providerStatus.style.backgroundColor = '#f8d7da';
                    providerStatus.style.color = '#721c24';
                    providerStatus.style.borderColor = '#f5c6cb';
                } else {
                    providerStatus.style.backgroundColor = '#d4edda';
                    providerStatus.style.color = '#155724';
                    providerStatus.style.borderColor = '#c3e6cb';
                }
            }
            
            // Add event listeners
            providerSelect.addEventListener('change', updateProviderUI);
            
            // Save API key on change
            document.getElementById('gemini-api-key').addEventListener('input', function() {
                localStorage.setItem('gemini-api-key', this.value);
            });
            
            // Initial update
            updateProviderUI();
        }

        async function processTableOCR() {
            if (!currentSelection) {
                console.warn('No selection available for OCR');
                return;
            }
            
            const statusDiv = document.getElementById('table-ocr-status');
            
            try {
                statusDiv.textContent = 'Processing image with OCR...';
                statusDiv.style.color = '#007bff';
                
                // Extract high-res image for OCR
                const imageData = await extractImageFromSelection(currentSelection);
                
                statusDiv.textContent = 'Detecting table structure...';
                
                // Get OCR options
                const providerSelect = document.getElementById('ocr-provider');
                const apiKeyInput = document.getElementById('gemini-api-key');
                
                const options = {};
                if (providerSelect.value !== 'auto') {
                    options.provider = providerSelect.value;
                }
                if (apiKeyInput.value) {
                    options.apiKey = apiKeyInput.value;
                }
                
                // Process with OCR module
                const result = await window.OCRTableExtractor.extractTable(imageData, options);
                
                if (result.success) {
                    const confidence = result.confidence || 0;
                    statusDiv.textContent = `✓ Table detected (${confidence.toFixed(1)}% confidence) - ${result.provider}`;
                    statusDiv.style.color = '#28a745';
                    
                    // Store OCR result for this session
                    currentOCRResult = result;
                    
                    // Build preview content with table and notes
                    let previewContent = result.markdown || '';
                    
                    // Add notes section if available
                    const notes = result.notes || result.tableData?.notes;
                    if (notes && notes.hasNotes) {
                        previewContent += '\n\n## Installation Notes & Requirements\n';
                        previewContent += `**Total Notes:** ${notes.count}\n\n`;
                        
                        notes.entries.forEach((note, index) => {
                            const cleanNote = note.replace(/^\d+\)\s*/, '');
                            previewContent += `${index + 1}. ${cleanNote}\n`;
                        });
                    }
                    
                    outputDiv.textContent = previewContent;
                    
                    // Auto-populate extraction name if detected
                    if (result.tableData && result.tableData.isTable && result.text && result.text.toLowerCase().includes('schedule')) {
                        const nameField = document.getElementById('extraction-name');
                        const extractionTypeField = document.getElementById('extraction-type');
                        if (!nameField.value) {
                            const titleMatch = result.text.match(/([A-Z\s]*SCHEDULE)/i);
                            if (titleMatch) {
                                nameField.value = titleMatch[1].trim();
                                extractionTypeField.value = 'schedule';
                            }
                        }
                    }
                } else {
                    statusDiv.textContent = `✗ ${result.error}`;
                    statusDiv.style.color = '#dc3545';
                    outputDiv.textContent = result.fallbackText || 'OCR processing failed';
                }
                
            } catch (error) {
                console.error('OCR processing error:', error);
                statusDiv.textContent = `✗ Error: ${error.message}`;
                statusDiv.style.color = '#dc3545';
                outputDiv.textContent = 'OCR processing failed';
            }
        }

        function generateExtractionName() {
            const equipmentSelect = document.getElementById('equipment-type');
            const extractionSelect = document.getElementById('extraction-type');
            const customEquipmentInput = document.getElementById('custom-equipment-type');
            const nameInput = document.getElementById('extraction-name');
            
            // Debug: Check if elements exist
            if (!equipmentSelect || !extractionSelect || !nameInput) {
                console.error('Name generation failed: Missing DOM elements');
                return;
            }
            
            // Get the current equipment type
            let equipmentType = equipmentSelect.value;
            console.log('Raw equipment type:', equipmentType); // Debug
            
            if (equipmentType === 'CUSTOM') {
                const customValue = customEquipmentInput ? customEquipmentInput.value.trim() : '';
                if (customValue) {
                    equipmentType = customValue.toUpperCase();
                } else {
                    // If CUSTOM is selected but no custom type entered yet, use placeholder
                    equipmentType = 'CUSTOM';
                }
            }
            
            // Fallback if equipment type is empty
            if (!equipmentType) {
                equipmentType = 'FANS'; // Default fallback
            }
            
            // Get extraction type and capitalize first letter
            const extractionType = extractionSelect.value;
            console.log('Raw extraction type:', extractionType); // Debug
            const capitalizedExtractionType = extractionType ? extractionType.charAt(0).toUpperCase() + extractionType.slice(1) : 'Schedule';
            
            // Generate base name
            const baseName = `${equipmentType} - ${capitalizedExtractionType}`;
            console.log('Generated base name:', baseName); // Debug
            
            // Check for existing names and add number if needed
            const existingNames = extractions.map(e => e.extractionName || e.name);
            let counter = 1;
            let uniqueName = baseName;
            
            while (existingNames.includes(uniqueName)) {
                counter++;
                uniqueName = `${baseName} ${counter}`;
            }
            
            console.log('Final unique name:', uniqueName); // Debug
            
            // Update the name input (only if it's currently auto-generated or empty)
            const currentName = nameInput.value.trim();
            console.log('Current name in input:', currentName); // Debug
            
            // Check if current name appears to be auto-generated (follows the pattern "TYPE - TYPE" or is empty)
            const autoGenPattern = /^[A-Z]+(?:\s+[A-Z]+)?\s*-\s*[A-Z][a-z]+(?:\s+\d+)?$/;
            const isAutoGenerated = !currentName || 
                                  currentName === nameInput.placeholder ||
                                  autoGenPattern.test(currentName) ||
                                  // Also update if the name contains any of the standard equipment types
                                  ['FANS', 'VAV', 'RTU', 'GRD', 'AHU', 'DUCTING', 'CUSTOM'].some(type => 
                                      currentName.includes(type + ' -'));
            
            if (isAutoGenerated || !currentName) {
                nameInput.value = uniqueName;
                console.log('Name input updated to:', uniqueName); // Debug
            } else {
                console.log('Name input left unchanged (appears to be user-modified)'); // Debug
            }
        }

        function handleEquipmentTypeChange() {
            const equipmentType = document.getElementById('equipment-type').value;
            const customGroup = document.getElementById('custom-equipment-group');
            
            if (equipmentType === 'CUSTOM') {
                customGroup.style.display = 'block';
                document.getElementById('custom-equipment-type').focus();
            } else {
                customGroup.style.display = 'none';
                document.getElementById('custom-equipment-type').value = '';
            }
            
            // Update auto-generated name
            generateExtractionName();
        }
        
        function handleExtractionTypeChange() {
            // Update auto-generated name when extraction type changes
            generateExtractionName();
        }
        
        // Throttle name generation for custom equipment type
        let customEquipmentTimeout = null;
        function handleCustomEquipmentTypeChange() {
            // Clear previous timeout
            if (customEquipmentTimeout) {
                clearTimeout(customEquipmentTimeout);
            }
            
            // Throttle name generation to avoid updating on every keystroke
            customEquipmentTimeout = setTimeout(() => {
                generateExtractionName();
            }, 300); // Wait 300ms after user stops typing
        }

        function closeModal() {
            modal.style.display = 'none';
            clearTempOverlay();
            currentSelection = null; // This also clears any spaceXref
            currentOCRResult = null; // Clear stored OCR result
            editingExtractionId = null; // Clear editing mode
            
            // Initialize search text state
            initializeSearchText();
            
            // Clear current OCR result
            currentOCRResult = null;
            
            // Set modal state and process any pending OCR
            isModalOpen = false;
            processPendingOCR();
            
            // Reset debug checkbox (with null check)
            const debugCheckbox = document.getElementById('debug-ocr');
            const debugDiv = document.getElementById('ocr-debug');
            if (debugCheckbox) debugCheckbox.checked = false;
            if (debugDiv) debugDiv.style.display = 'none';
            
            // Reset OCR table checkbox and completely clear OCR content (with null checks)
            const ocrCheckbox = document.getElementById('enable-table-ocr');
            const statusDiv = document.getElementById('table-ocr-status');
            const configGroup = document.getElementById('ocr-config-group');
            
            if (ocrCheckbox) ocrCheckbox.checked = false;
            if (statusDiv) {
                statusDiv.innerHTML = '';
                statusDiv.style.display = 'none';
            }
            // Markdown output removed from modal
            if (configGroup) configGroup.style.display = 'none';
            
            // Clear OCR preview
            const previewContainer = document.getElementById('ocr-preview');
            if (previewContainer) {
                previewContainer.innerHTML = '';
            }
            
            // Reset modal title
            const modalTitle = document.querySelector('#schedule-modal h2');
            if (modalTitle) {
                modalTitle.textContent = 'Extract Schedule';
            }
            
            // Clear form fields
            document.getElementById('extraction-name').value = '';
            document.getElementById('equipment-type').value = 'FANS';
            document.getElementById('custom-equipment-type').value = '';
            document.getElementById('custom-equipment-group').style.display = 'none';
            document.getElementById('extraction-type').value = 'schedule';
            document.getElementById('extraction-description').value = '';
            document.getElementById('rfq-required').checked = false;
        }

        async function saveSchedule() {
            const name = document.getElementById('extraction-name').value.trim();
            const equipmentType = document.getElementById('equipment-type').value;
            const customEquipmentType = document.getElementById('custom-equipment-type').value.trim().toUpperCase();
            const extractionType = document.getElementById('extraction-type').value;
            const description = document.getElementById('extraction-description').value.trim();
            const rfqRequired = document.getElementById('rfq-required').checked;
            
            if (!name) {
                alert('Please enter an extraction name');
                return;
            }
            
            // Determine final equipment type
            let finalEquipmentType = equipmentType;
            if (equipmentType === 'CUSTOM') {
                if (!customEquipmentType) {
                    alert('Please enter a custom equipment type');
                    return;
                }
                finalEquipmentType = customEquipmentType;
            }
            
            if (!currentSelection) {
                alert('No selection found');
                return;
            }
            
            // Ensure selection has required properties
            if (!currentSelection.page || typeof currentSelection.x !== 'number') {
                alert('Invalid selection coordinates');
                console.error('Invalid currentSelection:', currentSelection);
                return;
            }
            
            // Show loading message
            setStatus('Extracting high-resolution image...');
            
            try {
                // Extract image from PDF at high resolution
                const imageData = await extractImageFromSelection(currentSelection);
                
                // Use OCR data from modal if available
                const ocrData = currentOCRResult;

                // Check if we're editing an existing extraction or creating a new one
                if (editingExtractionId) {
                    // Update existing extraction
                    const existingIndex = extractions.findIndex(e => e.id === editingExtractionId);
                    if (existingIndex !== -1) {
                        const existing = extractions[existingIndex];
                        
                        // Update the extraction with new data
                        extractions[existingIndex] = {
                            ...existing, // Keep existing data like original timestamp, id
                            extractionName: name,
                            equipmentType: finalEquipmentType,
                            extractionType: extractionType,
                            description: description,
                            rfqRequired: rfqRequired,
                            coordinates: currentSelection,
                            imageData: imageData,
                            ocrData: ocrData !== null ? ocrData : existing.ocrData, // Use new OCR if provided, otherwise keep existing
                            ocrStatus: ocrData ? 'completed' : (existing.ocrData ? 'completed' : 'none'),
                            lastModified: new Date().toISOString(),
                            // Preserve space reference if it exists
                            ...(existing.spaceXref && { 
                                isBlueBeamSpace: existing.isBlueBeamSpace,
                                spaceXref: existing.spaceXref 
                            })
                        };
                        
                        setStatus(`${extractionType.charAt(0).toUpperCase() + extractionType.slice(1)} "${name}" updated successfully for ${finalEquipmentType}`);
                    }
                    
                    // Clear editing mode
                    editingExtractionId = null;
                } else {
                    // Create new extraction with simple UID
                    const extraction = {
                        id: generateExtractionUID(),
                        legacyId: ++extractionCounter, // Keep legacy counter for compatibility
                        extractionName: name,
                        equipmentType: finalEquipmentType,
                        extractionType: extractionType,
                        description: description,
                        rfqRequired: rfqRequired,
                        coordinates: currentSelection,
                        imageData: imageData,
                        ocrData: ocrData,
                        ocrStatus: ocrData ? 'completed' : 'none',
                        timestamp: new Date().toISOString(),
                        // Add space reference if this was converted from a BlueBeam space
                        ...(currentSelection.spaceXref && { 
                            isBlueBeamSpace: true,
                            spaceXref: currentSelection.spaceXref 
                        })
                    };
                    
                    // Mark space as imported if it's from a BlueBeam space
                    if (currentSelection.spaceXref && spaceManager && spaceManager.importedSpaces) {
                        spaceManager.importedSpaces.add(currentSelection.spaceXref);
                        
                        // Re-render spaces to show checkmark
                        const currentPageSpaces = spaceManager.getSpacesForPage(currentPage - 1);
                        if (currentPageSpaces && currentPageSpaces.length > 0) {
                            const pageInfo = spaceManager.pageInfo[currentPage - 1];
                            const pageHeight = pageInfo?.height || 792;
                            const pageWidth = pageInfo?.width || 612;
                            const rotation = pageInfo?.rotation || 0;
                            spaceManager.renderSpacesForPage(currentPage - 1, currentZoom, pageHeight, pageWidth, rotation);
                        }
                    }
                    
                    extractions.push(extraction);
                    setStatus(`${extractionType.charAt(0).toUpperCase() + extractionType.slice(1)} "${name}" extracted successfully for ${finalEquipmentType}`);
                }
                
                updateExtractionList();
                saveToLocalStorage();
                
                // Update Extract All button state
                extractAllBtn.disabled = extractions.length === 0;
                
                // Refresh the display to show the updated rectangle
                restoreSelectionsForPage(currentPage);
                
                // Close modal immediately for smooth workflow
                closeModal();
                
            } catch (error) {
                console.error('Error saving schedule:', error);
                setStatus('Error extracting schedule. Please try again.');
            }
        }

        async function extractImageFromSelection(selection) {
            try {
                // Create a high-resolution extraction directly from PDF
                const page = await currentPDF.getPage(selection.page);
                const extractionScale = 3.0; // High resolution for extraction
                const viewport = page.getViewport({ scale: extractionScale });
                
                // Create a temporary canvas for high-res rendering
                const tempCanvas = document.createElement('canvas');
                const tempCtx = tempCanvas.getContext('2d');
                
                // Set canvas size to full page at high resolution
                tempCanvas.width = viewport.width;
                tempCanvas.height = viewport.height;
                
                // Render the entire page at high resolution
                const renderContext = {
                    canvasContext: tempCtx,
                    viewport: viewport
                };
                await page.render(renderContext).promise;
                
                // COORDINATE SYSTEM EXPLANATION:
                // selection.x/y/width/height are normalized to PDF scale (1.0)
                // To map to extraction scale (3.0), we multiply by 3.0
                
                const scaleFactor = extractionScale; // 3.0
                
                const extractX = selection.x * scaleFactor;
                const extractY = selection.y * scaleFactor;
                const extractWidth = selection.width * scaleFactor;
                const extractHeight = selection.height * scaleFactor;
                
                console.log('Extraction debug:', {
                    selectionCoords: selection,
                    extractionScale,
                    scaleFactor,
                    extractCoords: { extractX, extractY, extractWidth, extractHeight },
                    canvasSize: { width: tempCanvas.width, height: tempCanvas.height }
                });
                
                // Ensure coordinates are within bounds
                const boundedX = Math.max(0, Math.min(extractX, tempCanvas.width));
                const boundedY = Math.max(0, Math.min(extractY, tempCanvas.height));
                const boundedWidth = Math.min(extractWidth, tempCanvas.width - boundedX);
                const boundedHeight = Math.min(extractHeight, tempCanvas.height - boundedY);
                
                if (boundedWidth <= 0 || boundedHeight <= 0) {
                    console.error('Invalid extraction bounds:', { boundedX, boundedY, boundedWidth, boundedHeight });
                    throw new Error('Invalid extraction coordinates');
                }
                
                // Create final extraction canvas
                const extractCanvas = document.createElement('canvas');
                const extractCtx = extractCanvas.getContext('2d');
                extractCanvas.width = boundedWidth;
                extractCanvas.height = boundedHeight;
                
                // Extract the specific region at high resolution
                const imageData = tempCtx.getImageData(boundedX, boundedY, boundedWidth, boundedHeight);
                extractCtx.putImageData(imageData, 0, 0);
                
                // Convert to base64 data URL
                return extractCanvas.toDataURL('image/png');
                
            } catch (error) {
                console.error('Error extracting high-res image:', error);
                // Fallback to canvas extraction if PDF extraction fails
                return extractImageFromCanvas(selection);
            }
        }

        function extractImageFromCanvas(selection) {
            // Fallback method using current canvas
            const tempCanvas = document.createElement('canvas');
            const tempCtx = tempCanvas.getContext('2d');
            
            const scaledCoords = scaleCoordinates(selection, currentZoom);
            
            tempCanvas.width = scaledCoords.width;
            tempCanvas.height = scaledCoords.height;
            
            const imageData = ctx.getImageData(scaledCoords.x, scaledCoords.y, scaledCoords.width, scaledCoords.height);
            tempCtx.putImageData(imageData, 0, 0);
            
            return tempCanvas.toDataURL('image/png');
        }

        function getExtractionTypeIcon(extractionType) {
            const icons = {
                'schedule': '📋',
                'drawing': '📐',
                'table': '📊',
                'detail': '🔍',
                'specification': '📄',
                'other': '📎'
            };
            return icons[extractionType] || '📎';
        }
        
        function getOCRStatusIcon(extraction) {
            const ocrStatus = extraction.ocrStatus || 'none';
            const hasOCRData = extraction.ocrData && extraction.ocrData.success;
            
            if (hasOCRData && ocrStatus === 'completed') {
                // Check if notes are present
                const notes = extraction.ocrData?.notes || extraction.ocrData?.tableData?.notes;
                const notesCount = notes?.count || 0;
                if (notesCount > 0) {
                    return `✅ 📝${notesCount}`; // Show checkmark with notes count
                }
                return '✅'; // Green checkmark - OCR completed successfully
            } else if (ocrStatus === 'processing') {
                return '🕐'; // Clock - OCR processing in progress
            } else if (ocrStatus === 'queued') {
                return '⏳'; // Hourglass - OCR queued for processing
            } else if (ocrStatus === 'failed') {
                return '⚠️'; // Warning - OCR failed
            } else {
                return ''; // No OCR status icon
            }
        }
        
        function formatOCRResultsForDisplay(extraction) {
            if (!extraction.ocrData || !extraction.ocrData.success) {
                return '';
            }
            
            let content = '';
            
            // Add the markdown table if available
            if (extraction.ocrData.markdown) {
                content += extraction.ocrData.markdown;
            }
            
            // Add notes section if available
            const notes = extraction.ocrData.notes || extraction.ocrData.tableData?.notes;
            if (notes && notes.hasNotes && notes.entries && notes.entries.length > 0) {
                content += '\n\n## Installation Notes & Requirements\n';
                content += `**Total Notes:** ${notes.count}\n\n`;
                
                notes.entries.forEach((note, index) => {
                    // Remove leading number if present (since we're adding our own)
                    const cleanNote = note.replace(/^\d+\)\s*/, '');
                    content += `${index + 1}. ${cleanNote}\n`;
                });
            }
            
            return content;
        }
        
        function toggleOCRResults(extractionId) {
            const resultsDiv = document.getElementById(`ocr-results-${extractionId}`);
            const toggleBtn = document.getElementById(`ocr-toggle-${extractionId}`);
            
            if (resultsDiv) {
                const isHidden = resultsDiv.style.display === 'none';
                resultsDiv.style.display = isHidden ? 'block' : 'none';
                if (toggleBtn) {
                    toggleBtn.textContent = isHidden ? 'Hide Results' : 'View Results';
                }
            }
        }

        // Show OCR results in a dedicated modal
        function showOCRResultsModal(extractionId) {
            const extraction = extractions.find(e => e.id === extractionId);
            if (!extraction || !extraction.ocrData) {
                alert('No OCR data available for this extraction.');
                return;
            }

            const modal = document.getElementById('ocr-results-modal');
            const title = document.getElementById('ocr-results-title');
            const contentDisplay = document.getElementById('ocr-content-display');
            const notesSection = document.getElementById('ocr-notes-section');
            const notesContent = document.getElementById('ocr-notes-content');
            const metadata = document.getElementById('ocr-metadata');
            const formatToggle = document.getElementById('ocr-format-toggle');

            if (!modal || !title || !contentDisplay || !notesSection || !notesContent || !metadata || !formatToggle) {
                console.error('OCR modal elements not found');
                return;
            }

            // Set modal title
            title.textContent = `OCR Results - ${extraction.extractionName || extraction.name || 'Extraction'}`;

            // Store extraction data on modal for toggle function
            modal.dataset.extractionId = extractionId;

            // Reset format toggle to default (show formatted table if available)
            formatToggle.checked = true;

            // Display OCR content
            displayOCRContent(extraction.ocrData, contentDisplay, formatToggle.checked);

            // Display installation notes if available
            const notes = extraction.ocrData.notes || extraction.ocrData.tableData?.notes;
            if (notes && notes.hasNotes && notes.entries && notes.entries.length > 0) {
                notesSection.style.display = 'block';
                
                let notesHTML = '<ol>';
                notes.entries.forEach((note, index) => {
                    // Remove leading number if present (since we're using ordered list)
                    const cleanNote = note.replace(/^\d+\)\s*/, '').trim();
                    notesHTML += `<li>${cleanNote}</li>`;
                });
                notesHTML += '</ol>';
                
                notesContent.innerHTML = notesHTML;
            } else {
                notesSection.style.display = 'none';
            }

            // Display metadata
            const provider = extraction.ocrData.provider || 'Unknown';
            const confidence = extraction.ocrData.confidence || 0;
            const isTable = extraction.ocrData.tableData?.isTable || false;
            
            let metadataHTML = `<strong>Provider:</strong> ${provider} | <strong>Confidence:</strong> ${confidence.toFixed(1)}% | <strong>Table Detected:</strong> ${isTable ? 'Yes' : 'No'}`;
            
            if (isTable && extraction.ocrData.tableData) {
                const tableData = extraction.ocrData.tableData.tableData || extraction.ocrData.tableData;
                if (tableData.rows && tableData.columns) {
                    metadataHTML += ` | <strong>Dimensions:</strong> ${tableData.rows} rows × ${tableData.columns} columns`;
                }
            }
            
            metadata.innerHTML = metadataHTML;

            // Show modal
            modal.style.display = 'block';
        }

        // Display OCR content based on format toggle
        function displayOCRContent(ocrData, contentDisplay, showFormatted) {
            if (!ocrData || !contentDisplay) return;

            if (showFormatted && ocrData.tableData?.isTable) {
                // Show as formatted HTML table
                contentDisplay.className = 'table-format';
                const tableHTML = convertMarkdownToTable(ocrData.markdown);
                if (tableHTML) {
                    contentDisplay.innerHTML = tableHTML;
                } else {
                    // Fallback to markdown text
                    contentDisplay.className = '';
                    contentDisplay.textContent = ocrData.markdown || ocrData.text || ocrData.rawText || 'No content available';
                }
            } else {
                // Show as raw markdown/text
                contentDisplay.className = '';
                contentDisplay.textContent = ocrData.markdown || ocrData.text || ocrData.rawText || 'No content available';
            }
        }

        // Convert markdown table to HTML table
        function convertMarkdownToTable(markdown) {
            if (!markdown || typeof markdown !== 'string') return null;

            const lines = markdown.trim().split('\n');
            if (lines.length < 3) return null; // Need at least header, separator, and one data row

            let tableHTML = '<table>';
            let headerProcessed = false;
            let separatorSkipped = false;

            for (const line of lines) {
                const trimmedLine = line.trim();
                
                // Skip empty lines
                if (!trimmedLine) continue;
                
                // Skip separator lines (contains only |, -, and spaces)
                if (/^[\|\-\s]+$/.test(trimmedLine)) {
                    separatorSkipped = true;
                    continue;
                }
                
                // Process table rows
                if (trimmedLine.startsWith('|') && trimmedLine.endsWith('|')) {
                    const cells = trimmedLine.split('|').slice(1, -1).map(cell => cell.trim());
                    
                    if (!headerProcessed) {
                        // Process header row
                        tableHTML += '<thead><tr>';
                        cells.forEach(cell => {
                            tableHTML += `<th>${cell}</th>`;
                        });
                        tableHTML += '</tr></thead><tbody>';
                        headerProcessed = true;
                    } else if (separatorSkipped) {
                        // Process data rows
                        tableHTML += '<tr>';
                        cells.forEach(cell => {
                            tableHTML += `<td>${cell}</td>`;
                        });
                        tableHTML += '</tr>';
                    }
                }
            }

            tableHTML += '</tbody></table>';
            
            // Validate that we have at least some table content
            if (!headerProcessed) return null;
            
            return tableHTML;
        }

        // Handle format toggle change
        function handleOCRFormatToggle() {
            const modal = document.getElementById('ocr-results-modal');
            const extractionId = modal?.dataset?.extractionId;
            
            if (!extractionId) return;
            
            const extraction = extractions.find(e => e.id === extractionId);
            if (!extraction || !extraction.ocrData) return;
            
            const contentDisplay = document.getElementById('ocr-content-display');
            const formatToggle = document.getElementById('ocr-format-toggle');
            
            if (contentDisplay && formatToggle) {
                displayOCRContent(extraction.ocrData, contentDisplay, formatToggle.checked);
            }
        }

        // Close OCR results modal
        function closeOCRResultsModal() {
            const modal = document.getElementById('ocr-results-modal');
            if (modal) {
                modal.style.display = 'none';
                // Clear stored extraction ID
                delete modal.dataset.extractionId;
            }
        }
        
        // Bulk Edit Modal functions removed - use Manage All instead
        // function openBulkEditModal() - removed
        
        // function closeBulkEditModal() - removed
        
        
        function openManageAllModal() {
            const modal = document.getElementById('manage-all-modal');
            const tbody = document.getElementById('manage-all-tbody');
            
            if (!modal || !tbody) return;
            
            // Get equipment types from settings
            const equipmentTypes = getEquipmentTypesFromSettings();
            
            // Clear and populate table
            tbody.innerHTML = '';
            
            extractions.forEach((extraction, index) => {
                const row = document.createElement('tr');
                row.style.borderBottom = '1px solid #eee';
                row.dataset.extractionId = extraction.id;
                
                // Build equipment type options
                const equipmentOptions = equipmentTypes
                    .filter(type => type.value !== 'CUSTOM') // Skip CUSTOM option
                    .map(type => {
                        const selected = extraction.equipmentType === type.value ? 'selected' : '';
                        return `<option value="${type.value}" ${selected}>${type.label || type.value}</option>`;
                    })
                    .join('');
                
                row.innerHTML = `
                    <td style="padding: 8px;">${extraction.extractionName || extraction.name}</td>
                    <td style="padding: 8px;">
                        <select class="equipment-type-select" data-extraction-id="${extraction.id}" style="width: 100%; padding: 4px;">
                            ${equipmentOptions}
                        </select>
                    </td>
                    <td style="padding: 8px; text-align: center;">${extraction.coordinates?.page || '?'}</td>
                    <td style="padding: 8px; text-align: center;">${extraction.ocrData?.success ? '✓' : '-'}</td>
                    <td style="padding: 8px; text-align: center;">${extraction.rfqRequired ? '✓' : '-'}</td>
                `;
                
                tbody.appendChild(row);
            });
            
            modal.style.display = 'block';
        }
        
        function closeManageAllModal() {
            const modal = document.getElementById('manage-all-modal');
            if (modal) {
                modal.style.display = 'none';
            }
        }
        
        function saveManageAllChanges() {
            const selects = document.querySelectorAll('.equipment-type-select');
            let changeCount = 0;
            
            selects.forEach(select => {
                const extractionId = select.dataset.extractionId;
                const newType = select.value;
                const extraction = extractions.find(e => e.id === extractionId);
                
                if (extraction && extraction.equipmentType !== newType) {
                    extraction.equipmentType = newType;
                    if (extraction.type) delete extraction.type;
                    changeCount++;
                }
            });
            
            if (changeCount > 0) {
                saveToLocalStorage();
                updateExtractionList();
                restoreSelectionsForPage(currentPage);
                
                const statusSpan = document.getElementById('manage-all-status');
                if (statusSpan) {
                    statusSpan.textContent = `Saved ${changeCount} change${changeCount !== 1 ? 's' : ''}`;
                    setTimeout(() => {
                        statusSpan.textContent = '';
                    }, 3000);
                }
            }
            
            closeManageAllModal();
        }
        
        function getEquipmentTypesFromSettings() {
            const settings = window.settingsManager ? window.settingsManager.getSettings() : null;
            if (settings && settings.equipmentTypes) {
                return settings.equipmentTypes;
            }
            // Fallback if settings not loaded
            return [
                { value: 'FANS', label: 'FANS (Fan Equipment)' },
                { value: 'VAV', label: 'VAV (Variable Air Volume)' },
                { value: 'RTU', label: 'RTU (Roof Top Units)' },
                { value: 'AHU', label: 'AHU (Air Handling Units)' },
                { value: 'GRD', label: 'GRD (Grilles/Diffusers)' },
                { value: 'DUCTING', label: 'DUCTING (Ductwork)' },
                { value: 'OTHER', label: 'OTHER' }
            ];
        }
        
        function populateEquipmentDropdown(selectElement, includeNoChange = false) {
            if (!selectElement) return;
            
            // Clear existing options
            selectElement.innerHTML = '';
            
            // Add "No Change" option if requested
            if (includeNoChange) {
                const noChangeOption = document.createElement('option');
                noChangeOption.value = '';
                noChangeOption.textContent = '-- No Change --';
                selectElement.appendChild(noChangeOption);
            }
            
            // Add equipment types from settings
            const equipmentTypes = getEquipmentTypesFromSettings();
            equipmentTypes.forEach(type => {
                // Skip CUSTOM option for bulk operations
                if (type.value === 'CUSTOM') return;
                
                const option = document.createElement('option');
                option.value = type.value;
                option.textContent = type.label || type.value;
                selectElement.appendChild(option);
            });
        }
        
        // function applyBulkEdit() - removed
        
        function getRFQIcon(extraction) {
            return extraction.rfqRequired ? '💰' : '';
        }
        
        async function processBackgroundOCR(extractionId, imageData) {
            try {
                console.log(`Starting background OCR processing for: ${extractionId}`);
                setStatus(`Processing OCR in background for extraction ${extractionId}...`);
                
                // Get OCR options
                const providerSelect = document.getElementById('ocr-provider');
                const apiKeyInput = document.getElementById('gemini-api-key');
                
                const options = {};
                if (providerSelect && providerSelect.value !== 'auto') {
                    options.provider = providerSelect.value;
                    console.log(`Using OCR provider: ${options.provider}`);
                }
                if (apiKeyInput && apiKeyInput.value) {
                    options.apiKey = apiKeyInput.value;
                    console.log('API key provided for OCR');
                }
                
                console.log('Calling OCR extraction...');
                // Process with OCR module
                const result = await window.OCRTableExtractor.extractTable(imageData, options);
                console.log('OCR extraction completed, result:', result);
                
                // Find the extraction and update it
                const extractionIndex = extractions.findIndex(e => e.id === extractionId);
                if (extractionIndex !== -1) {
                    if (result.success) {
                        extractions[extractionIndex].ocrData = result;
                        extractions[extractionIndex].ocrStatus = 'completed';
                        setStatus(`OCR completed successfully for extraction ${extractionId}`);
                    } else {
                        extractions[extractionIndex].ocrStatus = 'failed';
                        setStatus(`OCR failed for extraction ${extractionId}: ${result.error || 'Unknown error'}`);
                    }
                    
                    // Update the display and save
                    updateExtractionList();
                    saveToLocalStorage();
                }
                
            } catch (error) {
                console.error('Background OCR failed:', error);
                
                // Update extraction status to failed
                const extractionIndex = extractions.findIndex(e => e.id === extractionId);
                if (extractionIndex !== -1) {
                    extractions[extractionIndex].ocrStatus = 'failed';
                    updateExtractionList();
                    saveToLocalStorage();
                }
                
                setStatus(`OCR failed for extraction ${extractionId}: ${error.message}`);
            }
        }

        function updateExtractionList() {
            console.time('Update Extraction List DOM');
            
            // Update Delete All button visibility
            const deleteAllBtn = document.getElementById('delete-all-extractions');
            const manageAllBtn = document.getElementById('manage-all');
            if (deleteAllBtn) {
                deleteAllBtn.style.display = extractions.length > 0 ? 'inline-block' : 'none';
            }
            if (manageAllBtn) {
                manageAllBtn.style.display = extractions.length > 0 ? 'inline-block' : 'none';
            }
            
            if (extractions.length === 0) {
                extractionList.innerHTML = '<p style="color: #7f8c8d; font-style: italic;">No extractions saved yet</p>';
                console.timeEnd('Update Extraction List DOM');
                return;
            }
            
            extractionList.innerHTML = '';
            
            // Group extractions by equipment type
            const grouped = {};
            const equipmentOrder = ['FANS', 'VAV', 'RTU', 'AHU', 'GRD', 'DUCTING', 'OTHER'];
            
            extractions.forEach(extraction => {
                const equipmentType = extraction.equipmentType || extraction.type || 'OTHER';
                if (!grouped[equipmentType]) {
                    grouped[equipmentType] = [];
                }
                grouped[equipmentType].push(extraction);
            });
            
            // Add custom equipment types to order if they exist
            Object.keys(grouped).forEach(type => {
                if (!equipmentOrder.includes(type)) {
                    equipmentOrder.push(type);
                }
            });
            
            // Render each group
            equipmentOrder.forEach(equipmentType => {
                if (!grouped[equipmentType] || grouped[equipmentType].length === 0) return;
                
                // Create group header
                const groupHeader = document.createElement('div');
                groupHeader.style.cssText = `
                    font-weight: bold;
                    margin-top: 15px;
                    margin-bottom: 8px;
                    padding: 5px;
                    background: linear-gradient(to right, ${getEquipmentTypeColorCSS(equipmentType)}, transparent);
                    border-left: 3px solid ${getEquipmentTypeBorderColor(equipmentType)};
                `;
                groupHeader.textContent = `${equipmentType} (${grouped[equipmentType].length})`;
                extractionList.appendChild(groupHeader);
                
                // Add items in this group
                grouped[equipmentType].forEach(extraction => {
                    const item = document.createElement('div');
                    item.className = 'extraction-item';
                    if (selectedExtractionId === extraction.id) {
                        item.classList.add('selected');
                    }
                    
                    const extractionTypeIcon = getExtractionTypeIcon(extraction.extractionType || 'other');
                    const ocrStatusIcon = getOCRStatusIcon(extraction);
                    const rfqIcon = getRFQIcon(extraction);
                    
                    // Check if OCR results are available
                    const hasOCRResults = extraction.ocrData && extraction.ocrData.success;
                    const ocrContent = hasOCRResults ? formatOCRResultsForDisplay(extraction) : '';
                    
                    item.innerHTML = `
                        <div class="extraction-title">
                            ${extractionTypeIcon} ${extraction.extractionName || extraction.name}
                            <span style="float: right;">
                                ${rfqIcon}${rfqIcon ? ' ' : ''}${ocrStatusIcon}
                            </span>
                        </div>
                        <div class="extraction-coords">
                            Page ${extraction.coordinates?.page || 'Unknown'} • ${extraction.equipmentType || extraction.type || 'UNKNOWN'}
                            ${extraction.description || extraction.notes ? ` • ${extraction.description || extraction.notes}` : ''}
                        </div>
                        <div style="margin-top: 5px;">
                            <button class="btn" style="font-size: 12px; padding: 4px 8px; margin-right: 5px;" 
                                    onclick="event.stopPropagation(); editExtraction('${extraction.id}')">
                                Edit
                            </button>
                            <button class="btn" style="font-size: 12px; padding: 4px 8px; margin-right: 5px;" 
                                    onclick="event.stopPropagation(); downloadImage('${extraction.id}')">
                                Download
                            </button>
                            <button class="btn" style="font-size: 12px; padding: 4px 8px; margin-right: 5px; background: #e67e22;" 
                                    onclick="event.stopPropagation(); runOCRForExtraction('${extraction.id}')"
                                    ${extraction.ocrStatus === 'processing' ? 'disabled' : ''}>
                                ${extraction.ocrStatus === 'processing' ? 'Processing...' : 'Run OCR'}
                            </button>
                            ${hasOCRResults ? `
                                <button id="ocr-toggle-${extraction.id}" class="btn" style="font-size: 12px; padding: 4px 8px; margin-right: 5px; background: #27ae60;" 
                                        onclick="event.stopPropagation(); showOCRResultsModal('${extraction.id}')">
                                    View Results
                                </button>
                            ` : ''}
                            <button class="btn-secondary" style="font-size: 12px; padding: 4px 8px;" 
                                    onclick="event.stopPropagation(); deleteExtraction('${extraction.id}')">
                                Delete
                            </button>
                        </div>
                    `;
                    
                    item.addEventListener('click', () => {
                        selectExtraction(extraction.id);
                        highlightExtraction(extraction);
                    });
                    
                    // Add hover highlighting
                    item.addEventListener('mouseenter', () => {
                        highlightExtractionOnHover(extraction.id);
                    });
                    
                    item.addEventListener('mouseleave', () => {
                        removeHoverHighlight(extraction.id);
                    });
                    
                    extractionList.appendChild(item);
                });
            });
            
            console.timeEnd('Update Extraction List DOM');
        }

        function highlightExtraction(extraction) {
            // Navigate to the page if needed
            if (extraction.coordinates && currentPage !== extraction.coordinates.page) {
                currentPage = extraction.coordinates.page;
                updatePageInfo();
                renderPage(currentPage).then(() => {
                    showExtractionHighlight(extraction);
                });
            } else {
                showExtractionHighlight(extraction);
            }
        }

        function showExtractionHighlight(extraction) {
            if (!extraction.coordinates) {
                console.warn('Cannot highlight extraction: missing coordinates');
                return;
            }
            
            clearTempOverlay();
            const coords = extraction.coordinates;
            const scaledCoords = scaleCoordinates(coords, currentZoom);
            drawTempSelectionRect(scaledCoords.x, scaledCoords.y, scaledCoords.x + scaledCoords.width, scaledCoords.y + scaledCoords.height);
            
            // Remove highlight after 3 seconds
            setTimeout(() => {
                clearTempOverlay();
            }, 3000);
        }

        function highlightExtractionOnHover(extractionId) {
            // Only highlight if on the same page
            const extraction = extractions.find(e => e.id === extractionId);
            if (extraction && extraction.coordinates && extraction.coordinates.page === currentPage) {
                const savedRect = savedOverlay.querySelector(`[data-extraction-id="${extractionId}"]`);
                if (savedRect) {
                    savedRect.style.borderColor = '#f39c12';
                    savedRect.style.background = 'rgba(243, 156, 18, 0.2)';
                    savedRect.style.borderWidth = '3px';
                }
            }
        }

        function removeHoverHighlight(extractionId) {
            const extraction = extractions.find(e => e.id === extractionId);
            if (extraction && extraction.coordinates && extraction.coordinates.page === currentPage) {
                const savedRect = savedOverlay.querySelector(`[data-extraction-id="${extractionId}"]`);
                if (savedRect) {
                    // Reset to original equipment type colors
                    savedRect.className = `saved-rect equipment-type-${extraction.equipmentType || extraction.type}`;
                    if (selectedExtractionId === extractionId) {
                        savedRect.classList.add('selected');
                    }
                    // Clear any inline styles that override the CSS classes
                    savedRect.style.borderColor = '';
                    savedRect.style.background = '';
                    savedRect.style.borderWidth = '2px';
                }
            }
        }

        async function ensureImageExtracted(extraction, skipSave = false) {
            // If image data already exists, return it
            if (extraction.imageData && extraction.imageData !== null) {
                return extraction.imageData;
            }
            
            // If no coordinates, can't extract image
            if (!extraction.coordinates) {
                console.error('No coordinates for extraction:', extraction.id);
                return null;
            }
            
            try {
                setStatus(`Extracting image for ${extraction.extractionName}...`);
                const imageData = await extractImageFromSelection(extraction.coordinates);
                
                // Update the extraction with the image data
                extraction.imageData = imageData;
                // Remove the flag since we've now extracted
                delete extraction.needsImageExtraction;
                
                // Only save if not skipping (e.g., during export)
                if (!skipSave) {
                    saveToLocalStorage();
                }
                
                return imageData;
            } catch (error) {
                console.error('Failed to extract image:', error);
                setStatus('Failed to extract image');
                return null;
            }
        }

        async function downloadImage(extractionId) {
            // Find extraction by ID
            const extraction = extractions.find(e => e.id === extractionId);
            if (!extraction) {
                console.error('Extraction not found for download:', extractionId);
                return;
            }
            
            // Ensure image is extracted
            const imageData = await ensureImageExtracted(extraction);
            if (!imageData) {
                alert('Could not extract image for download');
                return;
            }
            
            const link = document.createElement('a');
            const name = extraction.extractionName || extraction.name;
            const equipmentType = extraction.equipmentType || extraction.type || 'UNKNOWN';
            link.download = `${equipmentType}_${name.replace(/[^a-z0-9]/gi, '_').toLowerCase()}_page${extraction.coordinates?.page || 'unknown'}.png`;
            link.href = imageData;
            link.click();
            setStatus(`Downloaded ${extraction.extractionName}`);
        }

        function selectExtraction(extractionId) {
            selectedExtractionId = extractionId;
            updateExtractionList();
            // Refresh display to update selection highlighting
            restoreSelectionsForPage(currentPage);
        }
        

        function editExtraction(extractionId) {
            // Find the extraction to edit
            const extraction = extractions.find(e => e.id === extractionId);
            if (!extraction) {
                alert('Extraction not found');
                return;
            }
            
            // Set editing mode
            editingExtractionId = extractionId;
            
            // Navigate to the correct page if needed
            if (extraction.coordinates && currentPage !== extraction.coordinates.page) {
                currentPage = extraction.coordinates.page;
                renderPage(currentPage).then(() => {
                    // Continue with opening the modal after page is rendered
                    openEditModal(extraction);
                });
            } else {
                openEditModal(extraction);
            }
        }
        
        function openEditModal(extraction) {
            // Set modal state
            isModalOpen = true;
            
            // Set editing mode
            editingExtractionId = extraction.id;
            console.log('Editing extraction with ID:', editingExtractionId);
            
            // Set the current selection to the extraction's coordinates
            currentSelection = extraction.coordinates;
            
            // Highlight the extraction area
            highlightExtraction(extraction);
            
            // Pre-fill the modal with existing data
            document.getElementById('extraction-name').value = extraction.extractionName || extraction.name || '';
            document.getElementById('extraction-description').value = extraction.description || '';
            
            // Set equipment type
            const equipmentSelect = document.getElementById('equipment-type');
            const equipmentType = extraction.equipmentType || extraction.type || 'OTHER';
            equipmentSelect.value = equipmentType;
            handleEquipmentTypeChange(); // Update custom input if needed
            
            // Set extraction type
            const extractionTypeSelect = document.getElementById('extraction-type');
            extractionTypeSelect.value = extraction.extractionType || 'schedule';
            
            // Set RFQ Required
            document.getElementById('rfq-required').checked = extraction.rfqRequired || false;
            
            // Clear any previous OCR data first and check for stored OCR for this UID
            currentOCRResult = null;
            
            // Clear OCR UI elements completely - use innerHTML to clear all HTML content
            document.getElementById('table-ocr-status').innerHTML = '';
            document.getElementById('table-ocr-status').style.display = 'none';
            document.getElementById('ocr-config-group').style.display = 'none';
            document.getElementById('enable-table-ocr').checked = false;
            
            // Clear OCR preview container
            const previewContainer = document.getElementById('ocr-preview');
            if (previewContainer) {
                previewContainer.innerHTML = '';
            }
            
            // If there's existing OCR data, set it up properly
            if (extraction.ocrData && extraction.ocrData.success) {
                // Set the current OCR result to the existing data (read-only in modal)
                currentOCRResult = extraction.ocrData;
                
                // Enable the OCR checkbox to show that OCR data exists
                document.getElementById('enable-table-ocr').checked = true;
                
                // Show the OCR status and make config visible
                document.getElementById('ocr-config-group').style.display = 'block';
                document.getElementById('table-ocr-status').style.display = 'block';
                
                // Show existing OCR results in the status area
                let statusText = `Existing OCR by ${extraction.ocrData.provider} (${extraction.ocrData.confidence}% confidence)`;
                if (extraction.ocrData.tableData && extraction.ocrData.tableData.isTable) {
                    const tableData = extraction.ocrData.tableData.tableData;
                    statusText += ` - Table: ${tableData.rows} rows × ${tableData.columns} columns`;
                }
                
                document.getElementById('table-ocr-status').innerHTML = `
                    <div style="color: green; font-weight: bold;">✓ ${statusText}</div>
                    <div style="margin-top: 5px; font-size: 12px; color: #666;">
                        OCR data will be preserved when saving. Uncheck "Extract Table Info" to remove OCR data, or run new OCR to replace it.
                    </div>
                `;
                
                // Show the markdown output if available
                if (extraction.ocrData.tableData && extraction.ocrData.tableData.isTable) {
                    const tableData = extraction.ocrData.tableData.tableData;
                    let markdownText = '';
                    
                    if (tableData.headers && tableData.data) {
                        // Create markdown table
                        markdownText = '| ' + tableData.headers.join(' | ') + ' |\n';
                        markdownText += '| ' + tableData.headers.map(() => '---').join(' | ') + ' |\n';
                        
                        tableData.data.forEach(row => {
                            markdownText += '| ' + row.join(' | ') + ' |\n';
                        });
                    } else if (extraction.ocrData.text) {
                        markdownText = extraction.ocrData.text;
                    }
                    
                    // Markdown text is now shown in the OCR results modal instead
                }
            }
            
            // Update modal title to indicate editing
            const modalTitle = document.querySelector('#schedule-modal h2');
            if (modalTitle) {
                modalTitle.textContent = 'Edit Schedule Extraction';
            }
            
            // Open the modal
            document.getElementById('schedule-modal').style.display = 'block';
        }

        async function runOCRForExtraction(extractionId) {
            // Find the extraction
            const extraction = extractions.find(e => e.id === extractionId);
            if (!extraction) {
                alert('Extraction not found');
                return;
            }
            
            // Update status to processing
            extraction.ocrStatus = 'processing';
            updateExtractionList();
            
            try {
                setStatus('Running OCR...');
                
                // Check if OCR is supported
                if (!window.OCRTableExtractor || !window.OCRTableExtractor.isSupported()) {
                    throw new Error('OCR functionality not available');
                }
                
                // Ensure image is extracted before running OCR
                const imageData = await ensureImageExtracted(extraction);
                if (!imageData) {
                    throw new Error('Could not extract image for OCR');
                }
                
                // Get OCR options - use saved API key if available
                const savedApiKey = localStorage.getItem('gemini-api-key');
                const ocrOptions = {
                    provider: savedApiKey ? 'gemini' : 'tesseract',
                    apiKey: savedApiKey
                };
                
                // Run OCR on the extraction's image
                const result = await window.OCRTableExtractor.extractTable(imageData, ocrOptions);
                
                if (result.success) {
                    // Update extraction with OCR results
                    extraction.ocrData = result;
                    extraction.ocrStatus = 'completed';
                    
                    // Check if notes were found
                    const notes = result.notes || result.tableData?.notes;
                    const notesCount = notes?.count || 0;
                    
                    if (notesCount > 0) {
                        setStatus(`✅ OCR completed for ${extraction.extractionName} - Found ${notesCount} installation notes`);
                    } else {
                        setStatus(`✅ OCR completed for ${extraction.extractionName}`);
                    }
                } else {
                    extraction.ocrStatus = 'failed';
                    setStatus(`OCR failed: ${result.error || 'Unknown error'}`);
                }
                
            } catch (error) {
                extraction.ocrStatus = 'failed';
                setStatus(`OCR failed: ${error.message}`);
                console.error('OCR error:', error);
            }
            
            // Update the UI and save
            updateExtractionList();
            saveToLocalStorage();
            
            // OCR completed - results can now be viewed in modal via "View Results" button
        }

        function deleteExtraction(extractionId) {
            if (confirm('Are you sure you want to delete this schedule?')) {
                // Find the extraction to get its spaceXref if it exists
                const extractionToDelete = extractions.find(e => e.id === extractionId);
                
                // If this extraction was from a BlueBeam space, remove it from imported spaces
                if (extractionToDelete && extractionToDelete.spaceXref && spaceManager && spaceManager.importedSpaces) {
                    spaceManager.importedSpaces.delete(extractionToDelete.spaceXref);
                    
                    // Re-render spaces to update checkmarks
                    const currentPageSpaces = spaceManager.getSpacesForPage(currentPage - 1);
                    if (currentPageSpaces && currentPageSpaces.length > 0) {
                        const pageInfo = spaceManager.pageInfo[currentPage - 1];
                        const pageHeight = pageInfo?.height || 792;
                        const pageWidth = pageInfo?.width || 612;
                        const rotation = pageInfo?.rotation || 0;
                        spaceManager.renderSpacesForPage(currentPage - 1, currentZoom, pageHeight, pageWidth, rotation);
                    }
                }
                
                extractions = extractions.filter(e => e.id !== extractionId);
                if (selectedExtractionId === extractionId) {
                    selectedExtractionId = null;
                }
                updateExtractionList();
                saveToLocalStorage();
                
                // Update button states
                extractAllBtn.disabled = extractions.length === 0;
                
                // Update Delete All button visibility
                const deleteAllBtn = document.getElementById('delete-all-extractions');
                if (deleteAllBtn) {
                    deleteAllBtn.style.display = extractions.length > 0 ? 'inline-block' : 'none';
                }
                
                // Refresh the display to remove deleted rectangles
                restoreSelectionsForPage(currentPage);
                
                setStatus('Schedule deleted successfully');
            }
        }

        function deleteAllExtractions() {
            const totalExtractions = extractions.length;
            
            if (totalExtractions === 0) {
                alert('No extractions to delete');
                return;
            }
            
            const message = `Are you sure you want to delete ALL ${totalExtractions} extraction${totalExtractions !== 1 ? 's' : ''}?\n\nThis action cannot be undone.`;
            
            if (confirm(message)) {
                // If using BlueBeam spaces, clear all imported spaces
                if (spaceManager && spaceManager.importedSpaces) {
                    // Find all extractions with spaceXref and remove from imported
                    extractions.forEach(extraction => {
                        if (extraction.spaceXref) {
                            spaceManager.importedSpaces.delete(extraction.spaceXref);
                        }
                    });
                    
                    // Re-render spaces to update checkmarks
                    const currentPageSpaces = spaceManager.getSpacesForPage(currentPage - 1);
                    if (currentPageSpaces && currentPageSpaces.length > 0) {
                        const pageInfo = spaceManager.pageInfo[currentPage - 1];
                        const pageHeight = pageInfo?.height || 792;
                        const pageWidth = pageInfo?.width || 612;
                        const rotation = pageInfo?.rotation || 0;
                        spaceManager.renderSpacesForPage(currentPage - 1, currentZoom, pageHeight, pageWidth, rotation);
                    }
                }
                
                // Clear all extractions
                extractions = [];
                selectedExtractionId = null;
                
                // Update UI
                updateExtractionList();
                saveToLocalStorage();
                
                // Clear all saved overlays
                clearSavedOverlay();
                
                // Update button states
                if (clearSelectionsBtn) clearSelectionsBtn.disabled = true;
                if (exportDataBtn) exportDataBtn.disabled = true;
                if (extractAllBtn) extractAllBtn.disabled = true;
                document.getElementById('delete-all-extractions').style.display = 'none';
                
                setStatus(`Deleted all ${totalExtractions} extraction${totalExtractions !== 1 ? 's' : ''}`);
            }
        }

        function restoreSelectionsForPage(pageNum) {
            // Clear saved overlay first to prevent duplicates
            clearSavedOverlay();
            
            const pageExtractions = extractions.filter(e => e.coordinates && e.coordinates.page === pageNum);
            pageExtractions.forEach(extraction => {
                const coords = extraction.coordinates;
                const selectionRect = document.createElement('div');
                selectionRect.className = `saved-rect equipment-type-${extraction.equipmentType || extraction.type}`;
                
                // Scale coordinates based on current zoom
                const scaledCoords = scaleCoordinates(coords, currentZoom);
                selectionRect.style.left = scaledCoords.x + 'px';
                selectionRect.style.top = scaledCoords.y + 'px';
                selectionRect.style.width = scaledCoords.width + 'px';
                selectionRect.style.height = scaledCoords.height + 'px';
                selectionRect.title = `${extraction.extractionName || extraction.name} (${extraction.equipmentType || extraction.type})`;
                selectionRect.dataset.extractionId = extraction.id;
                
                // Add click handler for selection
                selectionRect.addEventListener('click', function(e) {
                    e.stopPropagation();
                    selectExtraction(extraction.id);
                });
                
                // Update selection state
                if (selectedExtractionId === extraction.id) {
                    selectionRect.classList.add('selected');
                }
                
                savedOverlay.appendChild(selectionRect);
            });
        }

        function scaleCoordinates(coords, zoom) {
            // coords are normalized to PDF scale (1.0)
            // we need to convert to current display scale (1.5 * zoom)
            const currentDisplayScale = 1.5 * zoom;
            
            return {
                x: coords.x * currentDisplayScale,
                y: coords.y * currentDisplayScale,
                width: coords.width * currentDisplayScale,
                height: coords.height * currentDisplayScale
            };
        }

        function extractAllImages() {
            if (extractions.length === 0) {
                alert('No schedules to extract');
                return;
            }
            
            setStatus('Extracting all images...');
            
            extractions.forEach((extraction, index) => {
                setTimeout(async () => {
                    await downloadImage(extraction.id);
                    if (index === extractions.length - 1) {
                        setStatus(`All ${extractions.length} images extracted successfully`);
                    }
                }, index * 100); // Small delay between downloads
            });
        }

        function clearAllSelections() {
            if (confirm('Are you sure you want to clear all extracted schedules?')) {
                // If using BlueBeam spaces, clear all imported spaces
                if (spaceManager && spaceManager.importedSpaces) {
                    // Clear all imported space references
                    extractions.forEach(extraction => {
                        if (extraction.spaceXref) {
                            spaceManager.importedSpaces.delete(extraction.spaceXref);
                        }
                    });
                    
                    // Re-render spaces to remove checkmarks
                    const currentPageSpaces = spaceManager.getSpacesForPage(currentPage - 1);
                    if (currentPageSpaces && currentPageSpaces.length > 0) {
                        const pageInfo = spaceManager.pageInfo[currentPage - 1];
                        const pageHeight = pageInfo?.height || 792;
                        const pageWidth = pageInfo?.width || 612;
                        const rotation = pageInfo?.rotation || 0;
                        spaceManager.renderSpacesForPage(currentPage - 1, currentZoom, pageHeight, pageWidth, rotation);
                    }
                }
                
                extractions = [];
                extractionCounter = 0;
                selectedExtractionId = null;
                updateExtractionList();
                clearSavedOverlay();
                clearTempOverlay();
                localStorage.removeItem('pdfExtractorData');
                setStatus('All selections cleared');
            }
        }

        // Helper function to convert data URL to blob
        async function dataURLToBlob(dataURL) {
            const response = await fetch(dataURL);
            return await response.blob();
        }

        // PDF-LIB Coordinate Transformation Utilities
        function transformCoordinatesForPDFLib(coords, pageHeight) {
            // Convert from Canvas coordinates (top-left origin) to PDF coordinates (bottom-left origin)
            // coords are already normalized to PDF scale (1.0)
            return {
                x: coords.x,
                y: pageHeight - coords.y - coords.height, // Flip Y coordinate
                width: coords.width,
                height: coords.height
            };
        }

        function getEquipmentTypeColor(equipmentType) {
            const colors = {
                'FANS': { r: 0.16, g: 0.68, b: 0.38 },     // Green
                'VAV': { r: 0.90, g: 0.49, b: 0.13 },      // Orange  
                'GRD': { r: 0.61, g: 0.35, b: 0.71 },      // Purple
                'RTU': { r: 0.16, g: 0.50, b: 0.73 },      // Blue
                'AHU': { r: 0.89, g: 0.20, b: 0.29 },      // Red
                'DUCTING': { r: 0.20, g: 0.59, b: 0.86 },  // Light Blue
                'OTHER': { r: 0.58, g: 0.65, b: 0.65 },    // Gray
                'UNKNOWN': { r: 0.58, g: 0.65, b: 0.65 }   // Gray
            };
            return colors[equipmentType] || colors['OTHER'];
        }
        
        function getEquipmentTypeColorCSS(equipmentType) {
            const color = getEquipmentTypeColor(equipmentType);
            const r = Math.round(color.r * 255);
            const g = Math.round(color.g * 255);
            const b = Math.round(color.b * 255);
            return `rgba(${r}, ${g}, ${b}, 0.1)`;
        }
        
        function getEquipmentTypeBorderColor(equipmentType) {
            const color = getEquipmentTypeColor(equipmentType);
            const r = Math.round(color.r * 255);
            const g = Math.round(color.g * 255);
            const b = Math.round(color.b * 255);
            return `rgb(${r}, ${g}, ${b})`;
        }

        // Create annotated PDF with extraction rectangles
        async function createAnnotatedPDF(originalPdfData, extractionsData) {
            try {
                console.log('Creating annotated PDF with', extractionsData.length, 'extractions');
                console.log('PDF data size:', originalPdfData.byteLength, 'bytes');
                
                // Load the original PDF directly - should work now with cloned buffer
                const pdfDoc = await PDFLib.PDFDocument.load(originalPdfData);
                console.log('PDF loaded successfully');
                
                // Get pages
                const pages = pdfDoc.getPages();
                
                // Group extractions by page
                const extractionsByPage = {};
                extractionsData.forEach(extraction => {
                    const pageNum = extraction.coordinates?.page || 1;
                    if (!extractionsByPage[pageNum]) {
                        extractionsByPage[pageNum] = [];
                    }
                    extractionsByPage[pageNum].push(extraction);
                });
                
                // Add rectangles to each page
                Object.entries(extractionsByPage).forEach(([pageNum, pageExtractions]) => {
                    console.log(`Processing page ${pageNum} with ${pageExtractions.length} extractions`);
                    const pageIndex = parseInt(pageNum) - 1; // Convert to 0-based index
                    if (pageIndex < 0 || pageIndex >= pages.length) {
                        console.warn(`Page ${pageNum} is out of range (0-${pages.length-1})`);
                        return;
                    }
                    
                    const page = pages[pageIndex];
                    const pageHeight = page.getHeight();
                    console.log(`Page ${pageNum} dimensions: ${page.getWidth()} x ${pageHeight}`);
                    
                    pageExtractions.forEach((extraction, index) => {
                        // Transform coordinates for PDF-LIB
                        const pdfCoords = transformCoordinatesForPDFLib(extraction.coordinates, pageHeight);
                        
                        // Get equipment type color
                        const color = getEquipmentTypeColor(extraction.equipmentType || extraction.type || 'OTHER');
                        
                        // Create editable rectangle annotation (like BlueBeam)
                        const extractionName = extraction.extractionName || extraction.name || 'Extraction';
                        const equipmentType = extraction.equipmentType || extraction.type || 'OTHER';
                        const extractionType = extraction.extractionType || 'extraction';
                        
                        // Build comprehensive annotation content
                        const annotationContent = [
                            `${extractionName}`,
                            `Equipment: ${equipmentType}`,
                            `Type: ${extractionType.toUpperCase()}`,
                            extraction.description ? `Description: ${extraction.description}` : '',
                            `Page: ${extraction.coordinates?.page || 'Unknown'}`,
                            `Created: ${new Date(extraction.timestamp).toLocaleString()}`
                        ].filter(line => line).join('\n');
                        
                        // Create rectangle annotation using PDF-LIB's annotation system
                        try {
                            const annotationRef = pdfDoc.context.nextRef();
                            
                            // Create annotation dictionary with fill
                            const annotationDict = pdfDoc.context.obj({
                                Type: 'Annot',
                                Subtype: 'Square',
                                Rect: [pdfCoords.x, pdfCoords.y, pdfCoords.x + pdfCoords.width, pdfCoords.y + pdfCoords.height],
                                Contents: PDFLib.PDFString.of(annotationContent),
                                T: PDFLib.PDFString.of(`${equipmentType}_${index + 1}`), // Title
                                C: [color.r, color.g, color.b], // Border color
                                IC: [color.r, color.g, color.b], // Interior (fill) color  
                                CA: 0.8, // Border opacity
                                ca: 0.1, // Fill opacity (matching web interface)
                                Border: [0, 0, 2], // Border style [h-radius, v-radius, width]
                                BS: pdfDoc.context.obj({
                                    Type: 'Border',
                                    W: 2, // Width
                                    S: 'S' // Solid style
                                }),
                                F: 4, // Flags: Print (bit 3 = 4)
                                M: PDFLib.PDFString.of(new Date().toISOString()), // Modification date
                                NM: PDFLib.PDFString.of(`extraction_${extraction.id || index}`), // Unique name
                                P: page.ref, // Parent page reference
                                // Custom properties for construction data
                                RC: PDFLib.PDFString.of(JSON.stringify({
                                    extractionId: extraction.id,
                                    equipmentType: equipmentType,
                                    extractionType: extractionType,
                                    coordinates: extraction.coordinates,
                                    ocrData: extraction.ocrData ? {
                                        provider: extraction.ocrData.provider,
                                        confidence: extraction.ocrData.confidence
                                    } : null
                                }))
                            });
                            
                            // Register the annotation
                            pdfDoc.context.assign(annotationRef, annotationDict);
                            
                            // Add annotation to page
                            const pageDict = pdfDoc.context.lookup(page.ref);
                            const existingAnnots = pageDict.get(PDFLib.PDFName.of('Annots'));
                            
                            if (existingAnnots) {
                                existingAnnots.push(annotationRef);
                            } else {
                                pageDict.set(PDFLib.PDFName.of('Annots'), pdfDoc.context.obj([annotationRef]));
                            }
                            
                            console.log(`Created annotation for ${extractionName} at (${pdfCoords.x}, ${pdfCoords.y})`);
                            
                        } catch (annotationError) {
                            console.warn('Failed to create annotation, falling back to drawn rectangle:', annotationError);
                            
                            // Fallback to drawn rectangle if annotation creation fails
                            page.drawRectangle({
                                x: pdfCoords.x,
                                y: pdfCoords.y,
                                width: pdfCoords.width,
                                height: pdfCoords.height,
                                borderColor: PDFLib.rgb(color.r, color.g, color.b),
                                borderWidth: 2,
                                color: PDFLib.rgb(color.r, color.g, color.b),
                                opacity: 0.1
                            });
                        }
                    });
                });
                
                console.log('Adding document metadata...');
                
                // Add document metadata
                pdfDoc.setTitle('Construction Schedule Extractions - Annotated PDF');
                pdfDoc.setAuthor('PDF Schedule Extractor');
                pdfDoc.setSubject(`${extractionsData.length} schedule extractions marked on construction drawings`);
                pdfDoc.setCreator('PDF Schedule Extractor v2.0');
                pdfDoc.setProducer('PDF-LIB');
                
                const equipmentTypesCount = {};
                extractionsData.forEach(extraction => {
                    const type = extraction.equipmentType || extraction.type || 'OTHER';
                    equipmentTypesCount[type] = (equipmentTypesCount[type] || 0) + 1;
                });
                
                const equipmentSummary = Object.entries(equipmentTypesCount)
                    .map(([type, count]) => `${type}: ${count}`)
                    .join(', ');
                
                const keywords = ['construction', 'schedules', 'extraction', ...Object.keys(equipmentTypesCount)];
                console.log('Setting keywords:', keywords);
                pdfDoc.setKeywords(keywords);
                
                // Add a summary comment
                const totalPages = Object.keys(extractionsByPage).length;
                const summary = `Annotated PDF created on ${new Date().toLocaleString()}. Contains ${extractionsData.length} extractions across ${totalPages} pages. Equipment breakdown: ${equipmentSummary}`;
                console.log('Summary:', summary);
                
                console.log('Saving PDF...');
                // Return the PDF bytes
                const pdfBytes = await pdfDoc.save();
                console.log('PDF saved successfully, size:', pdfBytes.length, 'bytes');
                return pdfBytes;
                
            } catch (error) {
                console.error('Error creating annotated PDF:', error);
                throw new Error(`Failed to create annotated PDF: ${error.message}`);
            }
        }

        // Helper function to create text file content
        function createTextFile(extraction, equipmentType) {
            const content = [];
            content.push('='.repeat(60));
            content.push(`EXTRACTION DETAILS`);
            content.push('='.repeat(60));
            content.push('');
            content.push(`Extraction Name: ${extraction.extractionName}`);
            content.push(`Equipment Type: ${equipmentType}`);
            content.push(`Extraction Type: ${extraction.extractionType}`);
            content.push(`Description: ${extraction.description || 'No description'}`);
            content.push(`Page: ${extraction.coordinates?.page || 'Unknown'}`);
            content.push(`Timestamp: ${extraction.timestamp}`);
            content.push('');
            
            if (extraction.ocrData) {
                content.push('-'.repeat(40));
                content.push('OCR PROCESSING DETAILS');
                content.push('-'.repeat(40));
                content.push(`Provider: ${extraction.ocrData.provider || 'Unknown'}`);
                content.push(`Confidence: ${extraction.ocrData.confidence || 0}%`);
                content.push(`Table Detected: ${extraction.ocrData.tableData?.isTable ? 'Yes' : 'No'}`);
                content.push('');
                
                content.push('-'.repeat(40));
                content.push('EXTRACTED TEXT');
                content.push('-'.repeat(40));
                // Handle both old and new data structure formats
                const rawText = extraction.ocrData.rawText || 
                               extraction.ocrData.tableData?.rawText || 
                               extraction.ocrData.text || 
                               'No text extracted';
                content.push(rawText);
                content.push('');
                
                if (extraction.ocrData.markdown) {
                    content.push('-'.repeat(40));
                    content.push('TABLE DATA (MARKDOWN)');
                    content.push('-'.repeat(40));
                    content.push(extraction.ocrData.markdown);
                }
                
                // Add notes section if available - handle both old and new data structure formats
                const notes = extraction.ocrData.notes || extraction.ocrData.tableData?.notes;
                if (notes && notes.hasNotes) {
                    content.push('');
                    content.push('-'.repeat(40));
                    content.push('INSTALLATION NOTES & REQUIREMENTS');
                    content.push('-'.repeat(40));
                    content.push(`Total Notes: ${notes.count}`);
                    content.push('');
                    
                    notes.entries.forEach((note, index) => {
                        content.push(`${index + 1}. ${note.replace(/^\d+\)\s*/, '')}`);
                    });
                    content.push('');
                }
            } else {
                content.push('No OCR data available for this extraction.');
            }
            
            return content.join('\n');
        }

        // Helper function to create README file
        function createReadmeFile(mainData) {
            const content = [];
            content.push('PDF SCHEDULE EXTRACTOR - EXPORT PACKAGE');
            content.push('='.repeat(50));
            content.push('');
            content.push(`Project: ${mainData.project}`);
            content.push(`Export Date: ${mainData.exportDate}`);
            content.push(`Total Extractions: ${mainData.totalExtractions}`);
            content.push(`Equipment Types: ${mainData.equipmentTypes.join(', ')}`);
            content.push('');
            content.push('FILE STRUCTURE:');
            content.push('-'.repeat(30));
            content.push('');
            content.push('project_data.json     - Main project data (no images)');
            content.push('README.txt           - This file');
            content.push('');
            
            for (const equipmentType of mainData.equipmentTypes) {
                const count = mainData.equipment[equipmentType].length;
                content.push(`${equipmentType}/`);
                content.push(`  └── ${count} extraction${count !== 1 ? 's' : ''} with PNG, JSON, and TXT files`);
            }
            
            content.push('');
            content.push('FILE TYPES:');
            content.push('-'.repeat(20));
            content.push('*.png      - High-resolution extracted images');
            content.push('*_table.json - Detailed OCR results and table structure');
            content.push('*_text.txt   - Human-readable extraction details');
            content.push('');
            content.push('Generated by PDF Schedule Extractor v2.0');
            content.push(`https://github.com/anthropics/claude-code`);
            
            return content.join('\n');
        }

        async function exportExtractions() {
            if (extractions.length === 0) {
                alert('No extractions to export');
                return;
            }
            
            // Show progress modal
            const progressModal = document.getElementById('progress-modal');
            const progressTitle = document.getElementById('progress-title');
            const progressFill = document.getElementById('progress-fill');
            const progressText = document.getElementById('progress-text');
            
            progressModal.style.display = 'flex';
            progressTitle.textContent = 'Exporting Extractions to ZIP';
            progressFill.style.width = '0%';
            progressText.textContent = `Preparing ${extractions.length} extractions for export...`;
            
            try {
                // Create ZIP file
                const zip = new JSZip();
                
                // Group extractions by equipment type
                const equipmentGroups = {};
                extractions.forEach(extraction => {
                    const equipmentType = extraction.equipmentType || 'UNKNOWN';
                    if (!equipmentGroups[equipmentType]) {
                        equipmentGroups[equipmentType] = [];
                    }
                    equipmentGroups[equipmentType].push(extraction);
                });
                
                // Create main JSON without image data
                const mainData = {
                    project: document.title || 'PDF Schedule Extractions',
                    exportDate: new Date().toISOString(),
                    totalExtractions: extractions.length,
                    equipmentTypes: Object.keys(equipmentGroups),
                    equipment: {}
                };
                
                // Track progress
                let processedCount = 0;
                const totalCount = extractions.length;
                
                // Process each equipment type
                for (const [equipmentType, groupExtractions] of Object.entries(equipmentGroups)) {
                    progressText.textContent = `Processing ${equipmentType} equipment (${groupExtractions.length} items)...`;
                    
                    mainData.equipment[equipmentType] = [];
                    
                    for (let i = 0; i < groupExtractions.length; i++) {
                        const extraction = groupExtractions[i];
                        const safeName = extraction.extractionName.replace(/[^a-z0-9]/gi, '_').toLowerCase();
                        const pageNum = extraction.coordinates?.page || 'unknown';
                        const baseFileName = `${safeName}_page${pageNum}`;
                        
                        // Create extraction metadata (NO image data)
                        const extractionData = {
                            id: extraction.id,
                            extractionName: extraction.extractionName,
                            extractionType: extraction.extractionType,
                            description: extraction.description,
                            coordinates: extraction.coordinates,
                            ocrData: extraction.ocrData,
                            files: {
                                image: `${equipmentType}/${baseFileName}.png`,
                                tableData: extraction.ocrData ? `${equipmentType}/${baseFileName}_table.json` : null,
                                textData: extraction.ocrData ? `${equipmentType}/${baseFileName}_text.txt` : null
                            },
                            timestamp: extraction.timestamp
                        };
                        
                        mainData.equipment[equipmentType].push(extractionData);
                        
                        // Update progress for current extraction
                        processedCount++;
                        const progress = (processedCount / totalCount) * 100;
                        progressFill.style.width = `${progress}%`;
                        progressFill.textContent = `${Math.round(progress)}%`;
                        progressText.textContent = `Processing "${extraction.extractionName}" (${processedCount} of ${totalCount})...`;
                        
                        // Small delay to allow UI to update
                        await new Promise(resolve => setTimeout(resolve, 10));
                        
                        // Check if image needs extraction (for imported spaces without images)
                        if (!extraction.imageData && extraction.needsImageExtraction) {
                            progressText.textContent = `Extracting image for "${extraction.extractionName}"...`;
                        }
                        
                        // Ensure image is extracted and add PNG file to ZIP (skip save during export)
                        const imageData = await ensureImageExtracted(extraction, true);
                        if (imageData) {
                            const imageBlob = await dataURLToBlob(imageData);
                            zip.file(`${equipmentType}/${baseFileName}.png`, imageBlob);
                        }
                        
                        // Add table data JSON file if OCR data exists
                        if (extraction.ocrData) {
                            const tableDataStr = JSON.stringify(extraction.ocrData, null, 2);
                            zip.file(`${equipmentType}/${baseFileName}_table.json`, tableDataStr);
                            
                            // Add text file with human-readable content
                            const textContent = createTextFile(extraction, equipmentType);
                            zip.file(`${equipmentType}/${baseFileName}_text.txt`, textContent);
                        }
                    }
                }
                
                // Add main JSON file to ZIP
                zip.file('project_data.json', JSON.stringify(mainData, null, 2));
                
                // Add README file
                const readmeContent = createReadmeFile(mainData);
                zip.file('README.txt', readmeContent);
                
                // Add session file for easy re-import
                const sessionData = createSessionData();
                zip.file('session.pdfextractor.json', JSON.stringify(sessionData, null, 2));
                
                // Create annotated PDF if original PDF is available
                if (currentPDFData && typeof PDFLib !== 'undefined') {
                    try {
                        progressText.textContent = 'Creating annotated PDF with extraction highlights...';
                        
                        // Create annotated PDF with all extractions
                        const annotatedPdfBytes = await createAnnotatedPDF(currentPDFData, extractions);
                        
                        // Add annotated PDF to ZIP
                        zip.file('annotated_construction_schedules.pdf', annotatedPdfBytes);
                        
                        progressText.textContent = 'Annotated PDF created successfully...';
                        
                    } catch (error) {
                        console.error('Error creating annotated PDF:', error);
                        progressText.textContent = 'Could not create annotated PDF, continuing...';
                        // Continue with export even if annotated PDF fails
                        await new Promise(resolve => setTimeout(resolve, 500));
                    }
                }
                
                progressText.textContent = 'Compressing and generating ZIP file...';
                progressFill.style.width = '95%';
                progressFill.textContent = '95%';
                
                // Generate ZIP and download
                const zipBlob = await zip.generateAsync({ 
                    type: 'blob',
                    compression: 'DEFLATE',
                    compressionOptions: { level: 6 }
                });
                
                // Create properly typed blob for better security handling
                const typedBlob = new Blob([zipBlob], { type: 'application/zip' });
                
                // Final progress update
                progressFill.style.width = '100%';
                progressFill.textContent = '100%';
                progressText.textContent = 'Export complete! Starting download...';
                
                // Small delay to show completion
                await new Promise(resolve => setTimeout(resolve, 500));
                
                // Hide progress modal
                progressModal.style.display = 'none';
                
                // Create download link with proper cleanup
                const url = URL.createObjectURL(typedBlob);
                const link = document.createElement('a');
                link.download = `construction_extractions_${new Date().toISOString().slice(0, 10)}.zip`;
                link.href = url;
                
                // Add link to DOM temporarily (helps with some browsers)
                document.body.appendChild(link);
                
                // Small delay before clicking to ensure proper registration
                await new Promise(resolve => setTimeout(resolve, 50));
                link.click();
                
                // Clean up
                document.body.removeChild(link);
                setTimeout(() => URL.revokeObjectURL(url), 100);
                
                setStatus(`✓ Exported ${extractions.length} extractions as organized ZIP file`);
                
            } catch (error) {
                console.error('Export error:', error);
                // Hide progress modal on error
                progressModal.style.display = 'none';
                setStatus('✗ Export failed. Please try again.');
            }
        }

        function saveToLocalStorage() {
            // Use hybrid save which will try server first, then fall back to localStorage
            saveSessionHybrid();
        }

        function loadFromLocalStorage() {
            try {
                console.time('localStorage Load');
                const data = localStorage.getItem('pdfExtractorData');
                console.log('localStorage data size:', data ? data.length : 0, 'characters');
                
                if (data) {
                    console.time('JSON Parse');
                    const parsed = JSON.parse(data);
                    console.timeEnd('JSON Parse');
                    
                    extractions = parsed.extractions || [];
                    extractionCounter = parsed.counter || 0;
                    console.log('Loaded extractions:', extractions.length);
                    
                    console.time('Update Extraction List');
                    updateExtractionList();
                    console.timeEnd('Update Extraction List');
                }
                console.timeEnd('localStorage Load');
            } catch (error) {
                console.error('Error loading from localStorage:', error);
            }
        }

        function setStatus(message) {
            statusText.textContent = message;
        }

        // ============================================================
        // SESSION MANAGEMENT FUNCTIONS
        // ============================================================
        
        // Create session data object
        function createSessionData() {
            const sessionData = {
                version: "1.0",
                pdfFileName: currentPDFFile ? currentPDFFile.name : 'unknown.pdf',
                pdfFileSize: currentPDFFile ? currentPDFFile.size : 0,
                lastModified: new Date().toISOString(),
                extractionCounter: extractionCounter,
                extractions: extractions.map(e => {
                    // Clone extraction but exclude imageData to save space
                    const { imageData, ...extractionWithoutImage } = e;
                    return extractionWithoutImage;
                }),
                blueBeamSpaces: {
                    importedSpaces: spaceManager?.importedSpaces ? 
                        Array.from(spaceManager.importedSpaces) : []
                }
            };
            return sessionData;
        }
        
        // Wrapper for backward compatibility
        function saveSessionToLocalStorage() {
            saveSessionHybrid();
        }
        
        // Load session from localStorage
        function loadSessionFromLocalStorage(fileName) {
            const sessionKey = `pdfExtractor_session_${fileName}`;
            try {
                const sessionData = localStorage.getItem(sessionKey);
                if (sessionData) {
                    const session = JSON.parse(sessionData);
                    console.log(`Session found for ${fileName}: ${session.extractions.length} extractions`);
                    return session;
                }
            } catch (error) {
                console.error('Error loading session:', error);
            }
            return null;
        }
        
        // Check if session exists
        function hasExistingSession(fileName) {
            const sessionKey = `pdfExtractor_session_${fileName}`;
            return localStorage.getItem(sessionKey) !== null;
        }
        
        // Clear session for specific file
        function clearSession(fileName) {
            const sessionKey = `pdfExtractor_session_${fileName}`;
            localStorage.removeItem(sessionKey);
            console.log(`Session cleared for ${fileName}`);
        }
        
        // Clear current session
        function clearCurrentSession() {
            if (!currentPDFFile) {
                alert('No PDF loaded');
                return;
            }
            
            if (confirm(`Clear session for ${currentPDFFile.name}? This will remove all extractions for this PDF.`)) {
                clearSession(currentPDFFile.name);
                resetExtractions();
                updateSessionStatus('Session cleared');
                setStatus('Session cleared - starting fresh');
            }
        }
        
        // Restore session data to application state
        function restoreSession(sessionData) {
            try {
                // Clear current data
                extractions = [];
                extractionCounter = sessionData.extractionCounter || 0;
                
                // Restore extractions
                sessionData.extractions.forEach(extraction => {
                    // Mark that images need regeneration
                    extraction.needsImageExtraction = true;
                    extractions.push(extraction);
                });
                
                // Restore BlueBeam imported spaces
                if (sessionData.blueBeamSpaces?.importedSpaces && spaceManager) {
                    spaceManager.importedSpaces = new Set(sessionData.blueBeamSpaces.importedSpaces);
                    // Re-render spaces with checkmarks
                    if (currentPage && spaceManager.pageInfo) {
                        const pageInfo = spaceManager.pageInfo[currentPage - 1];
                        if (pageInfo) {
                            spaceManager.renderSpacesForPage(
                                currentPage - 1, 
                                currentZoom, 
                                pageInfo.height || 792, 
                                pageInfo.width || 612, 
                                pageInfo.rotation || 0
                            );
                        }
                    }
                }
                
                // Update UI
                updateExtractionList();
                if (currentPage) {
                    restoreSelectionsForPage(currentPage);
                }
                
                // Update buttons
                document.getElementById('export-data').disabled = extractions.length === 0;
                document.getElementById('extract-all').disabled = extractions.length === 0;
                document.getElementById('delete-all-extractions').style.display = 
                    extractions.length > 0 ? 'inline-block' : 'none';
                document.getElementById('manage-all').style.display = 
                    extractions.length > 0 ? 'inline-block' : 'none';
                
                console.log(`Session restored: ${extractions.length} extractions`);
            } catch (error) {
                console.error('Error restoring session:', error);
                alert('Failed to restore session. Starting fresh.');
                resetExtractions();
            }
        }
        
        // Reset extractions (clear all)
        function resetExtractions() {
            extractions = [];
            extractionCounter = 0;
            selectedExtractionId = null;
            updateExtractionList();
            clearSavedOverlay();
            clearTempOverlay();
            
            // Clear BlueBeam imported spaces tracking
            if (spaceManager && spaceManager.importedSpaces) {
                spaceManager.importedSpaces.clear();
            }
            
            // Update button states
            document.getElementById('export-data').disabled = true;
            document.getElementById('extract-all').disabled = true;
            document.getElementById('delete-all-extractions').style.display = 'none';
            document.getElementById('manage-all').style.display = 'none';
        }
        
        // Update recent sessions list
        function updateRecentSessions(fileName) {
            try {
                let recent = JSON.parse(localStorage.getItem('pdfExtractor_recentSessions') || '[]');
                recent = recent.filter(f => f !== fileName);
                recent.unshift(fileName);
                recent = recent.slice(0, 10); // Keep last 10
                localStorage.setItem('pdfExtractor_recentSessions', JSON.stringify(recent));
            } catch (error) {
                console.error('Error updating recent sessions:', error);
            }
        }
        
        // Export session to file
        function exportSession() {
            if (!currentPDFFile) {
                alert('No PDF loaded');
                return;
            }
            
            try {
                const sessionData = createSessionData();
                const blob = new Blob([JSON.stringify(sessionData, null, 2)], 
                    { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `${currentPDFFile.name}.pdfextractor.session.json`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                
                setStatus('Session exported successfully');
            } catch (error) {
                console.error('Error exporting session:', error);
                alert('Failed to export session');
            }
        }
        
        // Import session from file
        async function importSession(file) {
            if (!file) return;
            
            try {
                const text = await file.text();
                const sessionData = JSON.parse(text);
                
                // Validate session data
                if (!sessionData.version || !sessionData.extractions) {
                    throw new Error('Invalid session file format');
                }
                
                // Warn if different PDF
                if (currentPDFFile && sessionData.pdfFileName !== currentPDFFile.name) {
                    if (!confirm(`This session is for "${sessionData.pdfFileName}" but current PDF is "${currentPDFFile.name}". Import anyway?`)) {
                        return;
                    }
                }
                
                // Restore the session
                restoreSession(sessionData);
                setStatus(`Session imported: ${sessionData.extractions.length} extractions loaded`);
                updateSessionStatus(`Session imported (${sessionData.extractions.length} extractions)`);
                
                // Save to localStorage for current file
                if (currentPDFFile) {
                    const sessionKey = `pdfExtractor_session_${currentPDFFile.name}`;
                    localStorage.setItem(sessionKey, JSON.stringify(sessionData));
                }
            } catch (error) {
                console.error('Error importing session:', error);
                alert('Failed to import session: ' + error.message);
            }
        }
        
        // Get time since last modified
        function getTimeSinceLastModified(isoDate) {
            const date = new Date(isoDate);
            const now = new Date();
            const diff = now - date;
            
            const minutes = Math.floor(diff / 60000);
            const hours = Math.floor(diff / 3600000);
            const days = Math.floor(diff / 86400000);
            
            if (days > 0) return `${days} day${days > 1 ? 's' : ''} ago`;
            if (hours > 0) return `${hours} hour${hours > 1 ? 's' : ''} ago`;
            if (minutes > 0) return `${minutes} minute${minutes > 1 ? 's' : ''} ago`;
            return 'just now';
        }
        
        // Update session status in UI
        function updateSessionStatus(message) {
            const statusElement = document.getElementById('session-info');
            if (statusElement) {
                statusElement.textContent = message;
            }
        }
        
        // Get storage info
        function getStorageInfo() {
            let totalSize = 0;
            let sessionCount = 0;
            
            for (let key in localStorage) {
                if (key.startsWith('pdfExtractor_session_')) {
                    totalSize += localStorage.getItem(key).length;
                    sessionCount++;
                }
            }
            
            return {
                usedKB: Math.round(totalSize / 1024),
                sessionCount: sessionCount,
                estimatedMaxKB: 5120 // ~5MB typical limit
            };
        }
        
        // Clean up old sessions (optional)
        function cleanupOldSessions(daysToKeep = 30) {
            const cutoffDate = new Date();
            cutoffDate.setDate(cutoffDate.getDate() - daysToKeep);
            let cleaned = 0;
            
            for (let key in localStorage) {
                if (key.startsWith('pdfExtractor_session_')) {
                    try {
                        const session = JSON.parse(localStorage.getItem(key));
                        if (new Date(session.lastModified) < cutoffDate) {
                            localStorage.removeItem(key);
                            cleaned++;
                        }
                    } catch (e) {
                        // Invalid session data, remove it
                        localStorage.removeItem(key);
                        cleaned++;
                    }
                }
            }
            
            if (cleaned > 0) {
                console.log(`Cleaned up ${cleaned} old sessions`);
            }
            return cleaned;
        }

        // ============================================================
        // END SESSION MANAGEMENT FUNCTIONS
        // ============================================================

        // ============================================================
        // SERVER DETECTION AND HYBRID SESSION MANAGEMENT
        // ============================================================
        
        // Check if Flask server is available
        async function checkServerStatus() {
            try {
                const response = await fetch('http://localhost:5000/api/health', {
                    method: 'GET',
                    mode: 'cors',
                    cache: 'no-cache'
                });
                
                if (response.ok) {
                    const data = await response.json();
                    serverAvailable = data.status === 'healthy';
                } else {
                    serverAvailable = false;
                }
            } catch (error) {
                console.log('Server not available:', error.message);
                serverAvailable = false;
            }
            
            updateServerStatusUI(serverAvailable);
            return serverAvailable;
        }
        
        // Update UI to show server status
        function updateServerStatusUI(available) {
            const statusIcon = document.getElementById('server-status-icon');
            const statusText = document.getElementById('server-status-text');
            const exportLocalBtn = document.getElementById('export-local');
            
            if (statusIcon && statusText) {
                if (available) {
                    statusIcon.textContent = '🟢';
                    statusText.textContent = 'Server Connected';
                    document.getElementById('server-status').style.background = 'rgba(46, 204, 113, 0.2)';
                } else {
                    statusIcon.textContent = '🔴';
                    statusText.textContent = 'Server Offline';
                    document.getElementById('server-status').style.background = 'rgba(0, 0, 0, 0.7)';
                }
            }
            
            // Show/hide export to local button based on server availability
            if (exportLocalBtn) {
                exportLocalBtn.style.display = available && extractions.length > 0 ? 'inline-block' : 'none';
            }
        }
        
        // Hybrid save session - try server first, fall back to localStorage
        async function saveSessionHybrid() {
            const sessionData = createSessionData();
            
            // Try server save first if available and we have a path
            if (serverAvailable && currentPDFPath) {
                try {
                    const response = await fetch('http://localhost:5000/api/session/save', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            pdf_path: currentPDFPath,
                            session_data: sessionData
                        })
                    });
                    
                    if (response.ok) {
                        const result = await response.json();
                        updateSessionStatus(`Session saved to file (${extractions.length} extractions)`);
                        console.log('Session saved to file:', result.path);
                        
                        // Also save to localStorage as backup
                        saveSessionToLocalStorageOnly(sessionData);
                        return;
                    }
                } catch (error) {
                    console.warn('Server save failed:', error);
                }
            }
            
            // Fall back to localStorage only
            saveSessionToLocalStorageOnly(sessionData);
        }
        
        // Direct localStorage save without recursion
        function saveSessionToLocalStorageOnly(sessionData) {
            if (!sessionData) {
                sessionData = createSessionData();
            }
            
            if (!currentPDFFile) {
                console.log('No PDF file loaded, skipping session save');
                return;
            }
            
            try {
                const sessionKey = `pdfExtractor_session_${currentPDFFile.name}`;
                const sessionString = JSON.stringify(sessionData);
                const sizeKB = Math.round(sessionString.length / 1024);
                
                if (sizeKB > 2048) {
                    console.warn(`Large session size: ${sizeKB}KB`);
                }
                
                localStorage.setItem(sessionKey, sessionString);
                updateRecentSessions(currentPDFFile.name);
                
                // Update session status in UI
                updateSessionStatus(`Session saved (${extractions.length} extractions)`);
                console.log(`Session saved to localStorage for ${currentPDFFile.name}: ${sizeKB}KB`);
                
                // DO NOT save legacy format with full images - it exceeds quota
                // The session format already excludes images (line 4759)
                
            } catch (error) {
                console.error('Error saving session:', error);
                if (error.name === 'QuotaExceededError') {
                    alert('Session storage full. Consider exporting your session or clearing old sessions.');
                }
            }
        }
        
        // Hybrid load session - try server first, fall back to localStorage
        async function loadSessionHybrid(fileName) {
            // Try server load first if available and we have a path
            if (serverAvailable && currentPDFPath) {
                try {
                    const response = await fetch(
                        `http://localhost:5000/api/session/load?pdf_path=${encodeURIComponent(currentPDFPath)}`
                    );
                    
                    if (response.ok) {
                        const data = await response.json();
                        if (data.success && data.session) {
                            console.log('Loaded session from file:', data.path);
                            updateSessionStatus('Session loaded from file');
                            return data.session;
                        }
                    }
                } catch (error) {
                    console.warn('Server load failed:', error);
                }
            }
            
            // Fall back to localStorage
            return loadSessionFromLocalStorage(fileName);
        }
        
        // Export to local directory (next to PDF)
        async function exportToLocalDirectory() {
            if (!serverAvailable || !currentPDFPath) {
                alert('Export to PDF folder requires the server to be running and a known PDF path.\n\nUse regular Export instead.');
                return;
            }
            
            if (extractions.length === 0) {
                alert('No extractions to export');
                return;
            }
            
            try {
                // Show progress
                setStatus('Creating export package...');
                
                // Generate the ZIP file (reuse existing export logic)
                const zip = new JSZip();
                
                // Group extractions by equipment type
                const equipmentGroups = {};
                extractions.forEach(extraction => {
                    const equipmentType = extraction.equipmentType || 'UNKNOWN';
                    if (!equipmentGroups[equipmentType]) {
                        equipmentGroups[equipmentType] = [];
                    }
                    equipmentGroups[equipmentType].push(extraction);
                });
                
                // Create folders and add files for each equipment type
                for (const [equipmentType, typeExtractions] of Object.entries(equipmentGroups)) {
                    // Create equipment folder
                    const folder = zip.folder(equipmentType);
                    
                    for (const extraction of typeExtractions) {
                        // Create safe filename
                        const safeName = (extraction.extractionName || extraction.name || 'extraction')
                            .replace(/[^a-z0-9]/gi, '_').toLowerCase();
                        const pageNum = extraction.coordinates?.page || 1;
                        const baseFileName = `${safeName}_page${pageNum}`;
                        
                        // Ensure image is extracted and add to ZIP (skip save during export)
                        const imageData = await ensureImageExtracted(extraction, true);
                        if (imageData) {
                            const imageBlob = await dataURLToBlob(imageData);
                            folder.file(`${baseFileName}.png`, imageBlob);
                        }
                        
                        // Add OCR data if available
                        if (extraction.ocrData) {
                            folder.file(`${baseFileName}_table.json`, JSON.stringify(extraction.ocrData, null, 2));
                            
                            const textContent = createTextFile(extraction, equipmentType);
                            folder.file(`${baseFileName}_text.txt`, textContent);
                        }
                    }
                }
                
                // Add main data file
                const mainData = {
                    project: document.getElementById('project-name')?.value || 'Construction Project',
                    exportDate: new Date().toISOString(),
                    pdfFile: currentPDFFile?.name || 'unknown.pdf',
                    equipment: equipmentGroups
                };
                zip.file('project_data.json', JSON.stringify(mainData, null, 2));
                
                // Add session file
                const sessionData = createSessionData();
                zip.file('session.pdfextractor.json', JSON.stringify(sessionData, null, 2));
                
                // Generate ZIP as blob
                const zipBlob = await zip.generateAsync({ type: 'blob' });
                
                // Convert to base64 for sending to server
                const reader = new FileReader();
                reader.onloadend = async function() {
                    const base64data = reader.result.split(',')[1];
                    
                    try {
                        const response = await fetch('http://localhost:5000/api/export/local', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({
                                pdf_path: currentPDFPath,
                                zip_data: base64data
                            })
                        });
                        
                        if (response.ok) {
                            const result = await response.json();
                            setStatus(`✅ Exported to: ${result.filename}`);
                            alert(`Export saved to PDF directory:\n${result.filename}`);
                        } else {
                            throw new Error('Export failed');
                        }
                    } catch (error) {
                        console.error('Export to local failed:', error);
                        // Fall back to download
                        const url = URL.createObjectURL(zipBlob);
                        const a = document.createElement('a');
                        a.href = url;
                        a.download = `${currentPDFFile?.name || 'export'}_extractions.zip`;
                        document.body.appendChild(a);
                        a.click();
                        document.body.removeChild(a);
                        URL.revokeObjectURL(url);
                        setStatus('Export downloaded (server save failed)');
                    }
                };
                reader.readAsDataURL(zipBlob);
                
            } catch (error) {
                console.error('Export error:', error);
                setStatus('Export failed');
                alert('Failed to create export package');
            }
        }
        
        // Note: saveToLocalStorage already calls saveSessionHybrid, no need to override
        
        // ============================================================
        // END SERVER DETECTION AND HYBRID SESSION MANAGEMENT
        // ============================================================

        // Don't auto-load old localStorage data when we have session management
        // Sessions are now loaded when PDFs are selected
        // setTimeout(() => {
        //     console.log('Loading saved data asynchronously...');
        //     loadFromLocalStorage();
        // }, 100);

        // Test function for debugging PDF-LIB integration
        window.testPDFLib = function() {
            console.log('Testing PDF-LIB availability...');
            console.log('PDFLib available:', typeof PDFLib !== 'undefined');
            console.log('Current PDF loaded:', currentPDF !== null);
            console.log('Current PDF data available:', currentPDFData !== null);
            console.log('Current extractions:', extractions.length);
            
            if (typeof PDFLib !== 'undefined') {
                console.log('PDF-LIB version:', PDFLib.version || 'Unknown');
                console.log('Available methods:', Object.getOwnPropertyNames(PDFLib.PDFDocument.prototype).filter(name => name.startsWith('set')));
            }
            
            return {
                pdfLibLoaded: typeof PDFLib !== 'undefined',
                pdfLoaded: currentPDF !== null,
                pdfDataAvailable: currentPDFData !== null,
                extractionCount: extractions.length
            };
        };

        // Search Text Functionality
        let currentSearches = [];
        let currentSearchMatches = [];

        function initializeSearchText() {
            // Reset search state
            currentSearches = [];
            currentSearchMatches = [];
            
            // Clear UI
            document.getElementById('search-input').value = '';
            document.getElementById('search-results').style.display = 'none';
            document.getElementById('search-list').innerHTML = '';
            document.getElementById('matches-list').innerHTML = '';
            
        }

        function addSearchTerm() {
            const searchInput = document.getElementById('search-input');
            const searchTerm = searchInput.value.trim();
            
            if (!searchTerm) {
                return;
            }
            
            // Check for duplicate
            if (currentSearches.includes(searchTerm)) {
                searchInput.value = '';
                return;
            }
            
            // Add search term
            currentSearches.push(searchTerm);
            searchInput.value = '';
            
            // Update UI
            updateSearchList();
            
            // Show results container if not visible
            document.getElementById('search-results').style.display = 'block';
        }

        function removeSearchTerm(searchTerm) {
            currentSearches = currentSearches.filter(term => term !== searchTerm);
            updateSearchList();
            
            // Hide results if no searches
            if (currentSearches.length === 0) {
                document.getElementById('search-results').style.display = 'none';
            }
        }

        function updateSearchList() {
            const searchList = document.getElementById('search-list');
            
            if (currentSearches.length === 0) {
                searchList.innerHTML = '<div class="search-no-results">No search terms added</div>';
                return;
            }
            
            searchList.innerHTML = currentSearches.map(term => `
                <div class="search-item">
                    <span class="search-item-text">${escapeHtml(term)}</span>
                    <button class="search-item-remove" onclick="removeSearchTerm('${escapeHtml(term)}')">×</button>
                </div>
            `).join('');
        }

        function performTextSearch() {
            if (currentSearches.length === 0 || !currentSelection) {
                return;
            }
            
            currentSearchMatches = [];
            
            try {
                // Search hierarchy: PDF text → OCR data → Run new OCR if needed
                
                // 1. Try PDF text layer first
                const textItems = getTextItemsInSelection(currentSelection);
                if (textItems && textItems.length > 0) {
                    const fullText = textItems.map(item => item.text).join(' ');
                    searchInText(fullText, 'PDF Text Layer');
                }
                
                // 2. Try existing OCR data
                if (currentOCRResult) {
                    searchInOCRData(currentOCRResult);
                }
                
                // 3. If no results and no OCR data, suggest running OCR
                if (currentSearchMatches.length === 0 && !currentOCRResult) {
                    displayNoResultsWithOCROption();
                    return;
                }
                
                displaySearchMatches(currentSearchMatches);
                
                
            } catch (error) {
                console.error('Search error:', error);
                displaySearchMatches([]);
            }
        }

        // Search in plain text (PDF text layer or OCR raw text)
        function searchInText(fullText, source) {
            currentSearches.forEach(searchTerm => {
                const regex = new RegExp(escapeRegExp(searchTerm), 'gi');
                let match;
                
                while ((match = regex.exec(fullText)) !== null) {
                    currentSearchMatches.push({
                        term: searchTerm,
                        match: match[0],
                        index: match.index,
                        source: source,
                        context: getContextAroundMatch(fullText, match.index, match[0].length)
                    });
                }
            });
        }

        // Search in OCR data (raw text, table data, and notes)
        function searchInOCRData(ocrResult) {
            if (!ocrResult) return;
            
            // Search in raw text if available
            if (ocrResult.text || ocrResult.rawText) {
                const rawText = ocrResult.rawText || ocrResult.text || '';
                searchInText(rawText, `OCR Text (${ocrResult.provider || 'Unknown'})`);
            }
            
            // Search in table data if available
            if (ocrResult.tableData && ocrResult.tableData.data) {
                searchInTableData(ocrResult.tableData, `OCR Table (${ocrResult.provider || 'Unknown'})`);
            }
            
            // Search in installation notes if available
            if (ocrResult.notes && ocrResult.notes.entries) {
                const notesText = ocrResult.notes.entries.join(' ');
                searchInText(notesText, `OCR Notes (${ocrResult.provider || 'Unknown'})`);
            }
        }

        // Search in structured table data
        function searchInTableData(tableData, source) {
            if (!tableData.headers || !tableData.data) return;
            
            const headers = tableData.headers;
            
            tableData.data.forEach((row, rowIndex) => {
                row.forEach((cellValue, colIndex) => {
                    currentSearches.forEach(searchTerm => {
                        const regex = new RegExp(escapeRegExp(searchTerm), 'gi');
                        if (regex.test(cellValue)) {
                            const headerName = headers[colIndex] || `Column ${colIndex + 1}`;
                            currentSearchMatches.push({
                                term: searchTerm,
                                match: cellValue,
                                source: source,
                                tableContext: {
                                    row: rowIndex + 1,
                                    column: headerName,
                                    fullRow: row,
                                    headers: headers
                                },
                                context: {
                                    before: `${headerName}: `,
                                    match: cellValue,
                                    after: ` (Row ${rowIndex + 1})`,
                                    truncatedStart: false,
                                    truncatedEnd: false
                                }
                            });
                        }
                    });
                });
            });
        }

        // Show no results with OCR option
        function displayNoResultsWithOCROption() {
            const matchesList = document.getElementById('matches-list');
            matchesList.innerHTML = `
                <div class="search-no-results">
                    <div style="margin-bottom: 10px;">No matches found in PDF text layer.</div>
                    <div style="margin-bottom: 10px; font-size: 12px; color: #666;">
                        This may be an image-based table. Try searching with OCR:
                    </div>
                    <button id="search-with-ocr-btn" class="btn" style="padding: 6px 12px; font-size: 12px;">
                        Search with OCR
                    </button>
                </div>
            `;
            
            // Add event listener for OCR search button
            document.getElementById('search-with-ocr-btn').addEventListener('click', searchWithNewOCR);
        }

        // Run OCR on current selection and search results
        async function searchWithNewOCR() {
            if (!currentSelection) return;
            
            try {
                setStatus('Running OCR for search...');
                
                // Extract image from current selection
                const imageData = await extractImageFromSelection(currentSelection);
                
                // Get OCR configuration (with fallback defaults)
                const ocrProvider = document.getElementById('ocr-provider')?.value || 'auto';
                const apiKey = document.getElementById('gemini-api-key')?.value || '';
                
                // Show OCR config if Gemini is selected but no API key
                if ((ocrProvider === 'auto' || ocrProvider === 'gemini') && !apiKey) {
                    const useGemini = confirm('Gemini OCR provides better results but requires an API key.\n\nClick OK to use Gemini (you\'ll need to configure API key) or Cancel to use Tesseract (local processing).');
                    if (useGemini) {
                        // Enable OCR section to show configuration
                        const ocrConfigGroup = document.getElementById('ocr-config-group');
                        if (ocrConfigGroup) {
                            ocrConfigGroup.style.display = 'block';
                        }
                        setStatus('Please configure OCR settings and try again');
                        return;
                    }
                }
                
                // Run OCR
                const ocrResult = await window.OCRTableExtractor.extractTable(imageData, {
                    provider: ocrProvider === 'auto' ? undefined : ocrProvider,
                    apiKey: apiKey
                });
                
                if (ocrResult.success) {
                    // Store OCR result for future searches
                    currentOCRResult = ocrResult;
                    
                    // Clear previous matches and search in new OCR data
                    currentSearchMatches = [];
                    searchInOCRData(ocrResult);
                    displaySearchMatches(currentSearchMatches);
                    
                    setStatus(`OCR search completed using ${ocrResult.provider || 'OCR'}`);
                } else {
                    setStatus('OCR search failed: ' + (ocrResult.error || 'Unknown error'));
                    displaySearchMatches([]);
                }
                
            } catch (error) {
                console.error('OCR search error:', error);
                setStatus('OCR search failed: ' + error.message);
                displaySearchMatches([]);
            }
        }

        function getContextAroundMatch(text, index, matchLength) {
            const contextLength = 30;
            const start = Math.max(0, index - contextLength);
            const end = Math.min(text.length, index + matchLength + contextLength);
            
            const before = text.substring(start, index);
            const match = text.substring(index, index + matchLength);
            const after = text.substring(index + matchLength, end);
            
            return {
                before: before,
                match: match,
                after: after,
                truncatedStart: start > 0,
                truncatedEnd: end < text.length
            };
        }

        function displaySearchMatches(matches) {
            const matchesList = document.getElementById('matches-list');
            
            if (matches.length === 0) {
                matchesList.innerHTML = '<div class="search-no-results">No matches found in selection</div>';
                return;
            }
            
            // Group matches by term
            const groupedMatches = {};
            matches.forEach(match => {
                if (!groupedMatches[match.term]) {
                    groupedMatches[match.term] = [];
                }
                groupedMatches[match.term].push(match);
            });
            
            matchesList.innerHTML = Object.entries(groupedMatches).map(([term, termMatches]) => `
                <div style="margin-bottom: 8px;">
                    <div style="font-weight: 600; font-size: 12px; color: #2c3e50; margin-bottom: 3px;">
                        "${term}" (${termMatches.length} match${termMatches.length !== 1 ? 'es' : ''})
                    </div>
                    ${termMatches.map(match => `
                        <div class="search-match">
                            ${match.source ? `<div style="font-size: 10px; color: #7f8c8d; margin-bottom: 2px;">📍 ${match.source}</div>` : ''}
                            ${match.tableContext ? 
                                `<div style="font-size: 11px; color: #e67e22; margin-bottom: 2px;">📊 Table: ${match.tableContext.column}</div>` : ''
                            }
                            ${match.context.truncatedStart ? '...' : ''}${escapeHtml(match.context.before)}<span class="search-match-highlight">${escapeHtml(match.context.match)}</span>${escapeHtml(match.context.after)}${match.context.truncatedEnd ? '...' : ''}
                        </div>
                    `).join('')}
                </div>
            `).join('');
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        function escapeRegExp(string) {
            return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
        }


        // Keyboard shortcuts
        document.addEventListener('keydown', function(event) {
            if (event.ctrlKey || event.metaKey) {
                switch(event.key) {
                    case 'o':
                        event.preventDefault();
                        pdfInput.click();
                        break;
                    case 'e':
                        event.preventDefault();
                        exportExtractions();
                        break;
                }
            }
            
            // Page navigation
            if (currentPDF) {
                switch(event.key) {
                    case 'ArrowLeft':
                        if (currentPage > 1) changePage(-1);
                        break;
                    case 'ArrowRight':
                        if (currentPage < totalPages) changePage(1);
                        break;
                    case 'Escape':
                        closeModal();
                        break;
                }
            }
        });
    </script>
</body>
</html>