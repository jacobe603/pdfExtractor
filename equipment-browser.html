<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Equipment Browser - PDF Schedule Extractor</title>
    
    <!-- Settings Manager -->
    <script src="settings-manager.js"></script>
    
    <!-- ZIP File Support for loading exports -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    
    <!-- Shared Styles -->
    <link rel="stylesheet" href="shared-styles.css">
    
    <!-- Shared Utilities -->
    <script src="shared-utils.js"></script>
    
    <style>
        /* Equipment Browser Specific Styles */
        .toolbar {
            justify-content: space-between;
        }

        /* Removed - using shared styles */

        .extractions-grid {
            flex: 1;
            padding: 8px;
            overflow-y: auto;
            display: grid;
            gap: 8px;
            height: calc(100vh - 140px); /* Account for header and toolbar */
        }

        /* Dense grid for all items view */
        .grid-all-items {
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
        }

        /* Limited grid for filtered view - maximize width */
        .grid-filtered-triple {
            grid-template-columns: repeat(3, 1fr);
        }

        .grid-filtered-double {
            grid-template-columns: repeat(2, 1fr);
        }

        .grid-filtered-single {
            grid-template-columns: 1fr;
            padding: 0 40px; /* Minimal side padding for very wide screens */
        }

        /* Viewport-aware responsive grid with height optimization */
        @media (min-width: 2560px) {
            .grid-all-items {
                grid-template-columns: repeat(10, 1fr);
            }
            .grid-all-items .extraction-card {
                min-height: calc((100vh - 240px) / 3);
            }
        }

        @media (min-width: 1920px) and (max-width: 2559px) {
            .grid-all-items {
                grid-template-columns: repeat(8, 1fr);
            }
            .grid-all-items .extraction-card {
                min-height: calc((100vh - 240px) / 3.5);
            }
        }

        @media (min-width: 1600px) and (max-width: 1919px) {
            .grid-all-items {
                grid-template-columns: repeat(7, 1fr);
            }
        }

        @media (min-width: 1400px) and (max-width: 1599px) {
            .grid-all-items {
                grid-template-columns: repeat(6, 1fr);
            }
        }

        @media (min-width: 1200px) and (max-width: 1399px) {
            .grid-all-items {
                grid-template-columns: repeat(5, 1fr);
            }
        }

        @media (min-width: 1000px) and (max-width: 1199px) {
            .grid-all-items {
                grid-template-columns: repeat(4, 1fr);
            }
        }

        /* Tall screen optimization */
        @media (min-height: 1200px) {
            .grid-all-items .extraction-thumbnail {
                height: calc((100vh - 200px) / 3.5);
                max-height: 350px;
            }
            .grid-filtered-single .extraction-thumbnail {
                height: calc(100vh - 250px);
                max-height: 1000px;
            }
        }

        /* Ultra-wide screen optimization */
        @media (min-aspect-ratio: 21/9) {
            .grid-filtered-single {
                padding: 0 15%; /* More padding for ultra-wide screens */
            }
        }

        .extractions-list {
            flex: 1;
            padding: 20px;
            overflow-y: auto;
        }

        /* Base extraction card - using shared styles with customizations */
        .extraction-card {
            height: 100%; /* Fill available grid space */
            min-height: 300px;
        }

        .extraction-thumbnail {
            min-height: 200px; /* Fallback minimum */
        }

        /* Dynamic thumbnail size variations using viewport units */
        .grid-all-items .extraction-thumbnail {
            height: calc((100vh - 200px) / 4); /* Dynamic height based on viewport */
            min-height: 150px;
            max-height: 250px;
            margin-bottom: 8px;
        }

        .grid-filtered-triple .extraction-thumbnail,
        .grid-filtered-double .extraction-thumbnail {
            height: calc((100vh - 180px) / 2.2); /* Larger for filtered views */
            min-height: 300px;
            max-height: 500px;
            margin-bottom: 12px;
        }

        .grid-filtered-single .extraction-thumbnail {
            height: calc(100vh - 280px); /* Maximum height for single items */
            min-height: 400px;
            max-height: 800px;
            margin-bottom: 15px;
        }

        /* Card styling variations with flexible padding */
        .grid-all-items .extraction-card {
            padding: 8px;
            min-height: calc((100vh - 240px) / 4);
        }

        .grid-all-items .extraction-title {
            font-size: 13px;
            margin-bottom: 4px;
        }

        .grid-all-items .extraction-info {
            font-size: 11px;
        }

        /* Full-size cards for filtered view */
        .grid-filtered-single .extraction-card,
        .grid-filtered-double .extraction-card,
        .grid-filtered-triple .extraction-card {
            padding: 15px;
            min-height: calc((100vh - 220px) / 2.2);
        }

        /* Single item gets maximum space */
        .grid-filtered-single .extraction-card {
            min-height: calc(100vh - 180px);
            padding: 20px;
        }

        /* Make thumbnail flexible within card */
        .extraction-thumbnail {
            flex: 1;
        }

        /* Removed - using shared styles */

        /* Load data section customization */
        .load-data-section {
            margin: 5px;
        }

        /* Equipment Browser responsive overrides */
        @media (max-width: 768px) {
            .equipment-sidebar {
                max-height: 150px; /* Reduced to give more space to content */
            }
            
            .extractions-grid {
                gap: 6px;
                padding: 6px;
                height: calc(100vh - 180px); /* Account for collapsed sidebar */
            }
            
            /* Force all grid variations to single column on mobile */
            .grid-all-items,
            .grid-filtered-single,
            .grid-filtered-double,
            .grid-filtered-triple {
                grid-template-columns: 1fr !important;
                max-width: none;
            }
            
            /* Mobile-optimized thumbnail sizes */
            .grid-all-items .extraction-thumbnail,
            .grid-filtered-single .extraction-thumbnail,
            .grid-filtered-double .extraction-thumbnail,
            .grid-filtered-triple .extraction-thumbnail {
                height: calc(100vh - 350px) !important;
                min-height: 200px !important;
                max-height: 400px !important;
            }
            
            /* Mobile card optimization */
            .extraction-card {
                min-height: calc(100vh - 280px) !important;
            }
        }
    </style>
</head>
<body>
    <div class="toolbar">
        <div class="toolbar-left">
            <h1>Equipment Browser</h1>
        </div>
        <div>
            <a href="#" onclick="navigateToPDFViewer(); return false;" class="btn secondary">PDF Viewer</a>
        </div>
    </div>

    <div class="main-container">
        <div class="equipment-sidebar">
            <h3>Equipment Types</h3>
            <div class="equipment-filter">
                <div class="equipment-type active" data-equipment="all">
                    <span class="equipment-label">All Equipment</span>
                    <span class="equipment-count" id="total-count">0</span>
                </div>
            </div>
            <div id="equipment-types-list">
                <!-- Equipment types will be populated by JavaScript -->
            </div>
        </div>

        <div class="content-area">
            <div class="content-header">
                <div class="search-bar">
                    <input type="text" class="search-input" placeholder="Search across all extractions..." id="search-input">
                </div>
                <div class="view-controls">
                    <div class="view-toggle">
                        <button class="active" id="grid-view-btn">Grid</button>
                        <button id="list-view-btn">List</button>
                    </div>
                    <button class="btn" id="refresh-data-btn">Refresh</button>
                </div>
            </div>

            <div id="load-data-section" class="load-data-section">
                <h3>Load Extraction Data</h3>
                <p>Load your extracted schedules from exported folders or localStorage</p>
                <div style="margin-top: 15px;">
                    <div class="file-input">
                        <input type="file" id="load-folder-input" webkitdirectory directory multiple>
                        <label for="load-folder-input">Browse Folder</label>
                    </div>
                    <div class="file-input">
                        <input type="file" id="load-zip-input" accept=".zip">
                        <label for="load-zip-input">Load ZIP</label>
                    </div>
                    <button class="btn" id="load-local-storage-btn">Load from Current Session</button>
                </div>
                <div style="margin-top: 15px; padding-top: 15px; border-top: 1px solid #dee2e6;">
                    <p style="color: #6c757d; margin-bottom: 10px;">Or enter folder path directly:</p>
                    <div style="display: flex; gap: 10px; align-items: center;">
                        <input type="text" id="folder-path-input" placeholder="C:\Users\jacob\Claude\TEST DOCUMENTS\~1177070 Sales Plans thru Addm 1_extractions_20250826_144419" 
                               style="flex: 1; padding: 8px; border: 1px solid #ddd; border-radius: 4px;">
                        <button class="btn" id="load-path-btn">Load Path</button>
                    </div>
                </div>
            </div>

            <div id="extractions-container" class="extractions-grid" style="display: none;">
                <!-- Extractions will be populated by JavaScript -->
            </div>
        </div>
    </div>

    <div class="status-bar">
        <span id="status-text">Ready</span>
        <div class="server-status">
            <span class="status-indicator" id="server-indicator"></span>
            <span id="server-status-text">Checking server...</span>
        </div>
    </div>

    <!-- Extraction Details Modal -->
    <div id="extraction-modal" class="modal" style="display: none;">
        <div class="modal-content">
            <div class="modal-header">
                <h2 id="modal-extraction-title">Extraction Details</h2>
                <span class="close-btn" id="close-modal">&times;</span>
            </div>
            <div class="modal-body">
                <div class="modal-tabs">
                    <button class="tab-btn active" data-tab="preview">Preview</button>
                    <button class="tab-btn" data-tab="ocr">OCR Text</button>
                    <button class="tab-btn" data-tab="notes">Notes</button>
                    <button class="tab-btn" data-tab="files">Files</button>
                </div>
                
                <div id="tab-preview" class="tab-content active">
                    <div class="extraction-image-container">
                        <img id="modal-extraction-image" src="" alt="Extraction preview" style="max-width: 100%; height: auto;">
                    </div>
                    <div class="extraction-metadata">
                        <div class="meta-row">
                            <span class="meta-label">Equipment Type:</span>
                            <span id="modal-equipment-type"></span>
                        </div>
                        <div class="meta-row">
                            <span class="meta-label">Extraction Type:</span>
                            <span id="modal-extraction-type"></span>
                        </div>
                        <div class="meta-row">
                            <span class="meta-label">Page:</span>
                            <span id="modal-page-number"></span>
                        </div>
                    </div>
                </div>
                
                <div id="tab-ocr" class="tab-content">
                    <div class="ocr-text-container">
                        <div class="ocr-controls" style="margin-bottom: 15px;">
                            <label style="display: flex; align-items: center; gap: 8px;">
                                <input type="checkbox" id="format-toggle" onchange="toggleOCRFormat(this.checked)">
                                <span>Show as formatted table</span>
                            </label>
                        </div>
                        <div id="modal-ocr-content" class="ocr-content-display">
                            No OCR content available
                        </div>
                        <div id="modal-notes-section" class="notes-section" style="margin-top: 20px;">
                            <!-- Notes will be populated here -->
                        </div>
                    </div>
                </div>
                
                <div id="tab-notes" class="tab-content">
                    <div class="notes-container">
                        <h4>Installation Notes</h4>
                        <div id="modal-notes-list" class="notes-list">
                            No notes available
                        </div>
                    </div>
                </div>
                
                <div id="tab-files" class="tab-content">
                    <div class="files-container">
                        <h4>Associated Files</h4>
                        <div id="modal-files-list" class="files-list">
                            No files available
                        </div>
                        
                        <!-- Future SPEC attachment drop zone -->
                        <div class="spec-drop-zone" id="spec-drop-zone" style="display: none;">
                            <div class="drop-zone-content">
                                <div class="drop-zone-icon">📎</div>
                                <p><strong>Drop SPEC files here</strong></p>
                                <p>Drag and drop PDF specification files to attach them to this extraction</p>
                                <button class="btn" id="browse-spec-files">Browse Files</button>
                                <input type="file" id="spec-files-input" multiple accept=".pdf" style="display: none;">
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn" id="download-extraction-btn">Download Files</button>
                <button class="btn secondary" id="close-modal-btn">Close</button>
            </div>
        </div>
    </div>

    <style>
        /* Modal Styles */
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            z-index: 1000;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .modal-content {
            background: white;
            border-radius: 8px;
            width: 90%;
            max-width: 900px;
            max-height: 90vh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .modal-header {
            padding: 20px;
            border-bottom: 1px solid #dee2e6;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .modal-header h2 {
            margin: 0;
            color: #2c3e50;
        }

        .close-btn {
            font-size: 24px;
            cursor: pointer;
            color: #6c757d;
            line-height: 1;
        }

        .close-btn:hover {
            color: #e74c3c;
        }

        .modal-body {
            flex: 1;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        .modal-tabs {
            display: flex;
            border-bottom: 1px solid #dee2e6;
            background: #f8f9fa;
        }

        .tab-btn {
            background: none;
            border: none;
            padding: 12px 20px;
            cursor: pointer;
            font-weight: 500;
            color: #6c757d;
            transition: all 0.2s;
        }

        .tab-btn.active,
        .tab-btn:hover {
            color: #3498db;
            background: white;
            border-bottom: 2px solid #3498db;
        }

        .tab-content {
            flex: 1;
            padding: 20px;
            overflow-y: auto;
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        .extraction-image-container {
            text-align: center;
            margin-bottom: 20px;
        }

        .extraction-metadata {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 6px;
        }

        .meta-row {
            display: flex;
            margin-bottom: 8px;
        }

        .meta-label {
            font-weight: 600;
            width: 140px;
            color: #2c3e50;
        }

        .ocr-text-box {
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 6px;
            padding: 15px;
            margin-bottom: 20px;
            max-height: 300px;
            overflow-y: auto;
        }

        .ocr-text-box pre {
            white-space: pre-wrap;
            word-wrap: break-word;
            margin: 0;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
            line-height: 1.4;
        }

        .table-data-container {
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 6px;
            padding: 15px;
            max-height: 400px;
            overflow: auto;
        }

        .notes-list {
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 6px;
            padding: 15px;
        }

        .note-item {
            margin-bottom: 10px;
            padding: 8px;
            background: white;
            border-left: 3px solid #3498db;
            border-radius: 4px;
        }

        .files-list {
            display: grid;
            gap: 10px;
        }

        .file-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px;
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 6px;
        }

        .file-info {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .file-icon {
            width: 20px;
            height: 20px;
            background: #3498db;
            border-radius: 3px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 10px;
            font-weight: bold;
        }

        .modal-footer {
            padding: 20px;
            border-top: 1px solid #dee2e6;
            display: flex;
            justify-content: flex-end;
            gap: 10px;
        }

        /* Table styling for OCR data */
        .ocr-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 10px;
        }

        .ocr-table th,
        .ocr-table td {
            border: 1px solid #dee2e6;
            padding: 8px;
            text-align: left;
        }

        .ocr-table th {
            background: #f8f9fa;
            font-weight: 600;
        }

        .ocr-table tr:nth-child(even) {
            background: #f9f9f9;
        }

        /* OCR Content Display Styles */
        .ocr-table-container {
            margin: 15px 0;
        }

        .ocr-table-container table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 10px;
        }

        .ocr-table-container th,
        .ocr-table-container td {
            border: 1px solid #dee2e6;
            padding: 8px;
            text-align: left;
        }

        .ocr-table-container th {
            background: #f8f9fa;
            font-weight: 600;
        }

        .ocr-table-container tr:nth-child(even) {
            background: #f9f9f9;
        }

        .raw-markdown {
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 6px;
            padding: 15px;
            white-space: pre-wrap;
            font-family: monospace;
            font-size: 14px;
            max-height: 400px;
            overflow: auto;
        }

        .notes-section ul.notes-list {
            background: #e8f5e8;
            border: 1px solid #c3e6c3;
            border-radius: 6px;
            padding: 15px;
            margin: 10px 0;
            list-style-type: none;
            padding-left: 20px;
        }

        .notes-section ul.notes-list li {
            margin: 8px 0;
            padding-left: 0;
            position: relative;
        }

        .notes-section ul.notes-list li::before {
            content: "📌";
            position: absolute;
            left: -18px;
            top: 0;
        }

        .notes-section h4 {
            color: #2d5a2d;
            margin-bottom: 10px;
        }

        /* SPEC Drop Zone Styles */
        .spec-drop-zone {
            margin-top: 20px;
            padding: 30px;
            border: 2px dashed #dee2e6;
            border-radius: 8px;
            background: #f8f9fa;
            text-align: center;
            transition: all 0.3s ease;
        }

        .spec-drop-zone.drag-over {
            border-color: #3498db;
            background: #e3f2fd;
        }

        .drop-zone-content {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
        }

        .drop-zone-icon {
            font-size: 48px;
            opacity: 0.5;
            margin-bottom: 10px;
        }

        .spec-drop-zone p {
            margin: 5px 0;
            color: #6c757d;
        }

        .spec-drop-zone p strong {
            color: #2c3e50;
        }

        .spec-drop-zone .btn {
            margin-top: 10px;
            background: #8e44ad;
        }

        .spec-drop-zone .btn:hover {
            background: #7d3c98;
        }
    </style>

    <script>
        // Global variables
        let extractionsData = [];
        let filteredExtractions = [];
        let currentEquipmentFilter = 'all';
        let searchQuery = '';
        let viewMode = 'grid';
        let serverAvailable = false;
        let equipmentTypes = [];
        let currentDataSource = null; // Track current data source: 'folder', 'server', 'localStorage'

        // File management for dragged folders
        let draggedFiles = new Map(); // Map: relative_path -> File object
        let fileObjectUrls = new Map(); // Map: relative_path -> object_url
        let loadingInProgress = false; // Flag to prevent duplicate loads

        // Path normalization helper functions
        function extractRelativePath(webkitRelativePath) {
            // Extract the part after the first folder
            // e.g. "exported_data/KITCHEN EXHAUST/image.png" -> "KITCHEN EXHAUST/image.png"
            const parts = webkitRelativePath.split('/');
            if (parts.length > 1) {
                return parts.slice(1).join('/');
            }
            return webkitRelativePath;
        }

        function getPathVariations(path) {
            // Return all possible path variations for lookup
            const variations = [path];
            
            // Add version without leading folder if it exists
            const relativePath = extractRelativePath(path);
            if (relativePath !== path) {
                variations.push(relativePath);
            }
            
            // Add just the filename
            const filename = path.split('/').pop();
            if (filename !== path && filename !== relativePath) {
                variations.push(filename);
            }
            
            return variations;
        }

        function findObjectUrl(imagePath) {
            // Try to find object URL with different path variations
            const variations = getPathVariations(imagePath);
            
            for (const variation of variations) {
                const objectUrl = fileObjectUrls.get(variation);
                if (objectUrl) {
                    console.log(`Found object URL for "${imagePath}" using variation "${variation}"`);
                    return objectUrl;
                }
            }
            
            console.log(`No object URL found for "${imagePath}", tried:`, variations);
            return null;
        }

        // Escape HTML to prevent XSS (from standalone HTML)
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // Convert markdown table to HTML table (from standalone HTML)
        function convertMarkdownToTable(markdown) {
            if (!markdown || typeof markdown !== 'string') return null;
            
            const lines = markdown.trim().split('\n');
            if (lines.length < 3) return null; // Need at least header, separator, and one data row
            
            let tableHTML = '<table>';
            let headerProcessed = false;
            let inTableBody = false;
            
            for (const line of lines) {
                const trimmedLine = line.trim();
                
                // Skip empty lines
                if (!trimmedLine) continue;
                
                // Skip separator lines (contains only |, -, and spaces)
                if (/^[\|\-\s]+$/.test(trimmedLine)) {
                    if (headerProcessed && !inTableBody) {
                        tableHTML += '</thead><tbody>';
                        inTableBody = true;
                    }
                    continue;
                }
                
                // Process table rows
                if (trimmedLine.includes('|')) {
                    // Split by | and clean up
                    let cells = trimmedLine.split('|').map(cell => cell.trim());
                    
                    // Remove empty cells at the beginning and end
                    if (cells[0] === '') cells.shift();
                    if (cells[cells.length - 1] === '') cells.pop();
                    
                    if (cells.length > 0) {
                        if (!headerProcessed) {
                            // Process header row
                            tableHTML += '<thead><tr>';
                            cells.forEach(cell => {
                                tableHTML += `<th>${escapeHtml(cell)}</th>`;
                            });
                            tableHTML += '</tr>';
                            headerProcessed = true;
                        } else if (inTableBody) {
                            // Process data row
                            tableHTML += '<tr>';
                            cells.forEach(cell => {
                                tableHTML += `<td>${escapeHtml(cell)}</td>`;
                            });
                            tableHTML += '</tr>';
                        }
                    }
                }
            }
            
            // Close table structure
            if (inTableBody) {
                tableHTML += '</tbody>';
            } else if (headerProcessed) {
                tableHTML += '</thead>';
            }
            tableHTML += '</table>';
            
            return headerProcessed ? tableHTML : null;
        }

        // Display OCR content with format toggle (from standalone HTML)
        function displayOCRContent(ocrData, container, showFormatted) {
            if (!ocrData) return '';
            
            let content = '';
            
            if (showFormatted && ocrData.markdown && (ocrData.tableData?.isTable || ocrData.isTable)) {
                // Show as formatted HTML table
                const tableHTML = convertMarkdownToTable(ocrData.markdown);
                if (tableHTML) {
                    content = `<div class="ocr-table-container">${tableHTML}</div>`;
                } else {
                    // Fallback to raw markdown
                    content = `<div class="raw-markdown">${escapeHtml(ocrData.markdown)}</div>`;
                }
            } else if (ocrData.markdown || ocrData.rawText || ocrData.text) {
                // Show as raw markdown/text
                const textContent = ocrData.markdown || ocrData.rawText || ocrData.text || 'No content available';
                content = `<div class="raw-markdown">${escapeHtml(textContent)}</div>`;
            }
            
            return content;
        }

        // Toggle OCR format display
        function toggleOCRFormat(showFormatted) {
            const ocrContentEl = document.getElementById('modal-ocr-content');
            const extraction = ocrContentEl.extractionData;
            
            if (extraction && extraction.ocrData) {
                const content = displayOCRContent(extraction.ocrData, ocrContentEl, showFormatted);
                ocrContentEl.innerHTML = content || 'No OCR content available';
            }
        }

        // Initialize API utilities with configuration
        let SERVER_URL = '';
        async function initializeApiConfig() {
            try {
                // Initialize settings manager first
                const settings = await window.settingsManager.init();
                ApiUtils.init(settings);
                SERVER_URL = ApiUtils.getServerUrl();
                return true;
            } catch (error) {
                console.error('Failed to initialize API config:', error);
                // Fallback to hardcoded values
                SERVER_URL = `http://${window.location.hostname}:5000`;
                return false;
            }
        }

        // Initialize the application
        document.addEventListener('DOMContentLoaded', async function() {
            console.log('Equipment Browser initialized');
            
            // Initialize API configuration
            await initializeApiConfig();
            
            // Initialize settings
            await initializeSettings();
            
            // Check server status
            await checkServerStatus();
            
            // Setup event listeners
            setupEventListeners();
            setupModalEventListeners();
            
            // Cleanup on page unload to prevent memory leaks
            window.addEventListener('beforeunload', clearFileObjects);
            
            // Don't automatically load localStorage - let user choose data source
            // tryLoadFromLocalStorage() will only be called as fallback if needed
        });

        async function initializeSettings() {
            try {
                // Settings already initialized in initializeApiConfig, just get them
                const settings = window.settingsManager.getSettings();
                equipmentTypes = settings.equipmentTypes || [];
                renderEquipmentTypes();
            } catch (error) {
                console.error('Failed to initialize settings:', error);
                // Use fallback equipment types
                equipmentTypes = [
                    { value: 'FANS', label: 'FANS' },
                    { value: 'VAV', label: 'VAV' },
                    { value: 'RTU', label: 'RTU' },
                    { value: 'AHU', label: 'AHU' },
                    { value: 'GRD', label: 'GRD' },
                    { value: 'DUCTING', label: 'DUCTING' },
                    { value: 'OTHER', label: 'OTHER' }
                ];
                renderEquipmentTypes();
            }
        }

        function renderEquipmentTypes() {
            const container = document.getElementById('equipment-types-list');
            container.innerHTML = '';

            // Get unique equipment types from current extraction data
            const activeEquipmentTypes = new Set();
            extractionsData.forEach(extraction => {
                if (extraction.equipmentType) {
                    activeEquipmentTypes.add(extraction.equipmentType);
                }
            });

            // Convert to sorted array and create type objects
            const currentEquipmentTypes = Array.from(activeEquipmentTypes)
                .sort()
                .map(typeValue => {
                    // Try to find the label from settings, otherwise use the value as label
                    const settingsType = equipmentTypes.find(t => t.value === typeValue);
                    return {
                        value: typeValue,
                        label: settingsType ? settingsType.label : typeValue
                    };
                });

            // Only render equipment types that have extractions in the current data
            currentEquipmentTypes.forEach(type => {
                const count = getEquipmentCount(type.value);
                if (count > 0) { // Only show types with actual extractions
                    const div = document.createElement('div');
                    div.className = 'equipment-type';
                    div.dataset.equipment = type.value;
                    div.innerHTML = `
                        <span class="equipment-label">${type.label}</span>
                        <span class="equipment-count">${count}</span>
                    `;
                    container.appendChild(div);
                }
            });
        }

        function getEquipmentCount(equipmentType) {
            if (equipmentType === 'all') {
                return extractionsData.length;
            }
            return extractionsData.filter(ext => ext.equipmentType === equipmentType).length;
        }

        async function checkServerStatus() {
            try {
                const isHealthy = await ApiUtils.checkServerHealth();
                
                if (isHealthy) {
                    const response = await ApiUtils.fetchWithTimeout(ApiUtils.buildApiUrl('health'));
                
                    if (response.ok) {
                        const data = await response.json();
                        serverAvailable = data.status === 'healthy';
                        updateServerStatus(serverAvailable, serverAvailable ? 'Server online' : 'Server unhealthy');
                    } else {
                        throw new Error('Server not responding');
                    }
                }
            } catch (error) {
                console.error('Server health check failed:', error);
                serverAvailable = false;
                updateServerStatus(false, error.name === 'AbortError' ? 'Server timeout' : 'Server offline');
            }
        }

        function updateServerStatus(online, message) {
            const indicator = document.getElementById('server-indicator');
            const statusText = document.getElementById('server-status-text');
            
            if (online) {
                indicator.classList.add('online');
                statusText.textContent = message;
            } else {
                indicator.classList.remove('online');
                statusText.textContent = message;
            }
        }

        function setupEventListeners() {
            // Equipment type filtering
            document.addEventListener('click', function(e) {
                if (e.target.closest('.equipment-type')) {
                    const equipmentType = e.target.closest('.equipment-type').dataset.equipment;
                    setEquipmentFilter(equipmentType);
                }
            });

            // Search functionality
            document.getElementById('search-input').addEventListener('input', function(e) {
                searchQuery = e.target.value.toLowerCase();
                filterAndRenderExtractions();
            });

            // View toggle
            document.getElementById('grid-view-btn').addEventListener('click', function() {
                setViewMode('grid');
            });

            document.getElementById('list-view-btn').addEventListener('click', function() {
                setViewMode('list');
            });

            // Data loading
            document.getElementById('load-folder-input').addEventListener('change', handleFolderLoad);
            document.getElementById('load-zip-input').addEventListener('change', handleZipLoad);
            document.getElementById('load-local-storage-btn').addEventListener('click', tryLoadFromLocalStorage);
            document.getElementById('load-path-btn').addEventListener('click', handlePathLoad);
            document.getElementById('refresh-data-btn').addEventListener('click', refreshData);
        }

        function setEquipmentFilter(equipmentType) {
            currentEquipmentFilter = equipmentType;
            
            // Update UI
            document.querySelectorAll('.equipment-type').forEach(el => {
                el.classList.remove('active');
            });
            
            document.querySelector(`[data-equipment="${equipmentType}"]`).classList.add('active');
            
            // Filter and render
            filterAndRenderExtractions();
        }

        function setViewMode(mode) {
            viewMode = mode;
            
            // Update toggle buttons
            document.getElementById('grid-view-btn').classList.toggle('active', mode === 'grid');
            document.getElementById('list-view-btn').classList.toggle('active', mode === 'list');
            
            // Update container class
            const container = document.getElementById('extractions-container');
            container.className = mode === 'grid' ? 'extractions-grid' : 'extractions-list';
            
            // Re-render with new view
            renderExtractions();
        }

        function filterAndRenderExtractions() {
            filteredExtractions = extractionsData.filter(extraction => {
                // Equipment type filter
                if (currentEquipmentFilter !== 'all' && extraction.equipmentType !== currentEquipmentFilter) {
                    return false;
                }
                
                // Search filter
                if (searchQuery) {
                    const searchableText = [
                        extraction.extractionName || '',
                        extraction.equipmentType || '',
                        extraction.extractionType || '',
                        extraction.ocrText || '',
                        extraction.notes || ''
                    ].join(' ').toLowerCase();
                    
                    if (!searchableText.includes(searchQuery)) {
                        return false;
                    }
                }
                
                return true;
            });
            
            renderExtractions();
        }

        function renderExtractions() {
            const container = document.getElementById('extractions-container');
            
            if (filteredExtractions.length === 0) {
                container.innerHTML = `
                    <div class="no-results">
                        <h3>No extractions found</h3>
                        <p>Try adjusting your search or filter criteria</p>
                    </div>
                `;
                return;
            }
            
            // Apply smart grid layout for grid view
            if (viewMode === 'grid') {
                const itemCount = filteredExtractions.length;
                const isFiltered = currentEquipmentFilter !== 'all';
                
                // Clear all grid classes
                container.classList.remove('grid-all-items', 'grid-filtered-single', 'grid-filtered-double', 'grid-filtered-triple');
                
                if (!isFiltered) {
                    // All items - dense grid (5-8 columns based on screen)
                    container.classList.add('grid-all-items');
                } else {
                    // Filtered by equipment type - limited columns
                    if (itemCount === 1) {
                        container.classList.add('grid-filtered-single');
                    } else if (itemCount === 2) {
                        container.classList.add('grid-filtered-double');
                    } else {
                        container.classList.add('grid-filtered-triple');
                    }
                }
            }
            
            container.innerHTML = '';
            
            filteredExtractions.forEach(extraction => {
                const card = createExtractionCard(extraction);
                container.appendChild(card);
            });
        }

        function createExtractionCard(extraction) {
            const card = document.createElement('div');
            card.className = 'extraction-card';
            
            // Create thumbnail - simplified approach like extraction viewer
            let thumbnailHtml;
            let imagePath = '';
            
            // Get image path - handle both new and old formats
            if (extraction.files?.image) {
                imagePath = extraction.files.image;
            } else if (extraction.imageData) {
                imagePath = extraction.imageData;
            }
            
            if (imagePath) {
                if (imagePath.startsWith('data:')) {
                    // Base64 image data
                    thumbnailHtml = `<img src="${imagePath}" alt="Extraction thumbnail">`;
                } else {
                    // Check if we have an object URL for this path (folder loading)
                    const objectUrl = findObjectUrl(imagePath);
                    if (objectUrl) {
                        // Use object URL for folder-loaded images
                        thumbnailHtml = `<img src="${objectUrl}" alt="Extraction thumbnail">`;
                    } else {
                        // File path - try direct path first, then server fallback
                        thumbnailHtml = `<img src="${imagePath}" alt="Extraction thumbnail" onerror="this.onerror=null; if(this.src.indexOf('/api/extraction-file/') === -1 && '${serverAvailable}' === 'true') { this.src='${SERVER_URL}/api/extraction-file/' + encodeURIComponent('${imagePath}'); } else { this.parentElement.innerHTML='<div class=\\'placeholder\\'>Image not available</div>'; }">`;
                    }
                }
            } else {
                // No image available
                thumbnailHtml = `<div class="placeholder">No preview available</div>`;
            }
            
            // Get OCR preview text
            const ocrPreview = getOCRPreview(extraction);
            
            card.innerHTML = `
                <div class="extraction-thumbnail">
                    ${thumbnailHtml}
                </div>
                <div class="extraction-title">${extraction.extractionName || 'Untitled'}</div>
                <div class="extraction-meta">
                    <span class="meta-tag equipment">${extraction.equipmentType}</span>
                    <span class="meta-tag type">${extraction.extractionType}</span>
                    ${extraction.pageNumber ? `<span class="meta-tag">Page ${extraction.pageNumber + 1}</span>` : ''}
                </div>
                <div class="extraction-preview">${ocrPreview}</div>
                <div class="extraction-actions">
                    <button class="action-btn primary" onclick="viewExtractionDetails('${extraction.id}')">View Details</button>
                    <button class="action-btn" onclick="downloadExtraction('${extraction.id}')">Download</button>
                </div>
            `;
            
            // Add click handler to entire card to open details modal
            card.addEventListener('click', function(e) {
                // Don't trigger if clicking on action buttons
                if (!e.target.closest('.action-btn')) {
                    viewExtractionDetails(extraction.id);
                }
            });
            
            // Add hover cursor styling
            card.style.cursor = 'pointer';
            
            return card;
        }

        function getOCRPreview(extraction) {
            // Use comprehensive fallback pattern like standalone HTML
            if (extraction.ocrData) {
                const textContent = extraction.ocrData.markdown || extraction.ocrData.rawText || extraction.ocrData.text;
                if (textContent) {
                    return textContent.substring(0, 200) + '...';
                }
            }
            // Legacy fallback
            if (extraction.ocrText) {
                return extraction.ocrText.substring(0, 200) + '...';
            }
            return 'No OCR text available';
        }

        function tryLoadFromLocalStorage() {
            // Only load localStorage if no other data source is active
            if (currentDataSource !== null) {
                console.log(`Skipping localStorage load - already have data from ${currentDataSource}`);
                return false;
            }
            
            try {
                const stored = localStorage.getItem('pdfExtractions');
                if (stored) {
                    const localExtractions = JSON.parse(stored);
                    if (Array.isArray(localExtractions) && localExtractions.length > 0) {
                        currentDataSource = 'localStorage';
                        loadExtractionsData(localExtractions);
                        updateStatus(`Loaded ${localExtractions.length} extractions from current session`);
                        return true;
                    }
                }
                updateStatus('No data found in current session');
                return false;
            } catch (error) {
                console.error('Error loading from localStorage:', error);
                updateStatus('Error loading from current session');
                return false;
            }
        }

        function loadExtractionsData(data) {
            extractionsData = data;
            filteredExtractions = [...data];
            
            // Hide load data section and show extractions
            document.getElementById('load-data-section').style.display = 'none';
            document.getElementById('extractions-container').style.display = viewMode === 'grid' ? 'grid' : 'block';
            
            // Update equipment counts
            renderEquipmentTypes();
            document.getElementById('total-count').textContent = data.length;
            
            // Render extractions
            filterAndRenderExtractions();
        }

        function clearFileObjects() {
            console.log(`clearFileObjects called - revoking ${fileObjectUrls.size} URLs`);
            // Revoke all existing object URLs to prevent memory leaks
            fileObjectUrls.forEach((url, path) => {
                URL.revokeObjectURL(url);
                console.log(`Revoked object URL for: ${path}`);
            });
            
            // Clear the maps
            draggedFiles.clear();
            fileObjectUrls.clear();
        }

        function handleFolderLoad(event) {
            const files = Array.from(event.target.files);
            console.log('handleFolderLoad called with', files.length, 'files');
            
            // Prevent duplicate processing
            if (loadingInProgress) {
                console.log('Load already in progress, ignoring');
                return;
            }
            
            loadingInProgress = true;
            updateStatus('Loading folder data...');
            
            // Don't clear object URLs immediately - they might still be needed
            // Only clear if we detect we're loading a completely different folder
            console.log('Folder load started, keeping existing', fileObjectUrls.size, 'object URLs for now');
            
            // Store all files in our global map for direct access
            files.forEach(file => {
                if (file.webkitRelativePath) {
                    draggedFiles.set(file.webkitRelativePath, file);
                    
                    // Create object URLs for image files so browser can display them
                    if (file.type.startsWith('image/') || file.name.toLowerCase().endsWith('.png') || file.name.toLowerCase().endsWith('.jpg') || file.name.toLowerCase().endsWith('.jpeg')) {
                        const objectUrl = URL.createObjectURL(file);
                        
                        // Store object URL with multiple key formats for robust lookup
                        const pathVariations = getPathVariations(file.webkitRelativePath);
                        pathVariations.forEach(variation => {
                            fileObjectUrls.set(variation, objectUrl);
                        });
                        
                        console.log(`Created object URL for: ${file.webkitRelativePath} with variations:`, pathVariations);
                    }
                }
            });
            
            console.log(`Mapped ${draggedFiles.size} files, ${fileObjectUrls.size} image URLs`);
            
            // Look for project_data.json files
            const projectFiles = files.filter(file => file.name === 'project_data.json');
            
            if (projectFiles.length === 0) {
                updateStatus('No project_data.json found in selected folder');
                return;
            }
            
            // Load the first project file found
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const projectData = JSON.parse(e.target.result);
                    // For folder loading, determine the full base path
                    let basePath = '';
                    if (files.length > 0) {
                        const firstFile = files[0];
                        // Get the full parent directory path
                        if (firstFile.webkitRelativePath) {
                            const pathParts = firstFile.webkitRelativePath.split('/');
                            if (pathParts.length > 1) {
                                // Get the folder name only
                                const folderName = pathParts[0];
                                
                                // Try to construct the full path by finding the parent folder
                                // The file.name should match the folder name
                                if (firstFile.name === 'project_data.json') {
                                    // Try to extract full path from the file path
                                    // This is a workaround since browser file API doesn't give us full paths
                                    console.log('File webkitRelativePath:', firstFile.webkitRelativePath);
                                    console.log('File name:', firstFile.name);
                                    console.log('Folder name from path:', folderName);
                                    
                                    // Use folder name for now, but this will need server-side path resolution
                                    basePath = folderName;
                                }
                            }
                        }
                    }
                    
                    console.log('Using basePath for folder browse:', basePath);
                    
                    // Clear any existing data first - folder data takes priority
                    extractionsData = [];
                    filteredExtractions = [];
                    currentDataSource = 'folder';
                    
                    // Process data directly since we have all files locally
                    const extractions = extractFromProjectData(projectData, basePath);
                    loadExtractionsData(extractions);
                    updateStatus(`Loaded ${extractions.length} extractions from local folder`);
                    
                    console.log(`Loaded ${extractions.length} extractions with ${fileObjectUrls.size} images available locally`);
                } catch (error) {
                    console.error('Error parsing project data:', error);
                    updateStatus('Error loading project data');
                } finally {
                    loadingInProgress = false;
                }
            };
            reader.readAsText(projectFiles[0]);
        }

        function handleZipLoad(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            updateStatus('Loading ZIP file...');
            
            const reader = new FileReader();
            reader.onload = async function(e) {
                try {
                    const zip = await JSZip.loadAsync(e.target.result);
                    const projectFile = zip.file('project_data.json');
                    
                    if (!projectFile) {
                        updateStatus('No project_data.json found in ZIP file');
                        return;
                    }
                    
                    const projectText = await projectFile.async('text');
                    const projectData = JSON.parse(projectText);
                    const extractions = extractFromProjectData(projectData, ''); // ZIP files have relative paths
                    loadExtractionsData(extractions);
                    updateStatus(`Loaded ${extractions.length} extractions from ZIP`);
                } catch (error) {
                    console.error('Error loading ZIP:', error);
                    updateStatus('Error loading ZIP file');
                }
            };
            reader.readAsArrayBuffer(file);
        }

        function extractFromProjectData(projectData, baseFolderPath = '') {
            const extractions = [];
            
            if (projectData.equipment) {
                // New format with equipment organization
                Object.keys(projectData.equipment).forEach(equipmentType => {
                    projectData.equipment[equipmentType].forEach(item => {
                        // Convert relative file paths to absolute paths
                        let files = item.files;
                        if (files && baseFolderPath) {
                            files = {};
                            Object.keys(item.files).forEach(fileType => {
                                const relativePath = item.files[fileType];
                                if (relativePath && !relativePath.startsWith('C:') && !relativePath.startsWith('/')) {
                                    // It's a relative path, make it absolute
                                    // Use forward slashes consistently for the path separator
                                    const cleanBasePath = baseFolderPath.replace(/\\/g, '/');
                                    const cleanRelPath = relativePath.replace(/\\/g, '/');
                                    files[fileType] = cleanBasePath.endsWith('/') 
                                        ? cleanBasePath + cleanRelPath
                                        : cleanBasePath + '/' + cleanRelPath;
                                } else {
                                    files[fileType] = relativePath;
                                }
                            });
                        }
                        
                        extractions.push({
                            id: item.id || `${equipmentType}_${Date.now()}_${Math.random()}`,
                            extractionName: item.extractionName,
                            equipmentType: item.equipmentType || equipmentType,
                            extractionType: item.extractionType,
                            pageNumber: item.pageNumber,
                            ocrData: item.ocrData,
                            ocrText: item.ocrData ? item.ocrData.rawText : '',
                            notes: item.ocrData && item.ocrData.notes ? item.ocrData.notes.entries.join(' ') : '',
                            files: files
                        });
                    });
                });
            } else if (Array.isArray(projectData)) {
                // Legacy format - direct array
                projectData.forEach(item => {
                    extractions.push({
                        id: item.id || `${Date.now()}_${Math.random()}`,
                        extractionName: item.extractionName || item.name,
                        equipmentType: item.equipmentType || 'OTHER',
                        extractionType: item.extractionType || 'other',
                        pageNumber: item.pageNumber,
                        ocrData: item.ocrData,
                        ocrText: item.ocrData ? item.ocrData.rawText : (item.ocrText || ''),
                        notes: item.notes || '',
                        files: item.files
                    });
                });
            }
            
            return extractions;
        }

        async function handlePathLoad() {
            const folderPath = document.getElementById('folder-path-input').value.trim();
            if (!folderPath) {
                updateStatus('Please enter a folder path');
                return;
            }
            
            updateStatus('Loading from folder path...');
            
            try {
                const response = await fetch(`${SERVER_URL}/api/browse-extractions`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ folder_path: folderPath })
                });
                
                if (!response.ok) {
                    throw new Error(`Server error: ${response.status}`);
                }
                
                const data = await response.json();
                
                if (data.success && data.project_data) {
                    // Use the server-converted folder path for file resolution
                    const serverFolderPath = data.folder_path || folderPath;
                    console.log('Using server folder path:', serverFolderPath);
                    const extractions = extractFromProjectData(data.project_data, serverFolderPath);
                    loadExtractionsData(extractions);
                    updateStatus(`Loaded ${extractions.length} extractions from folder`);
                } else {
                    throw new Error(data.error || 'Failed to load project data');
                }
            } catch (error) {
                console.error('Error loading from path:', error);
                updateStatus(`Error loading folder: ${error.message}`);
            }
        }

        async function handleFolderServerLoad(projectData, folderName) {
            // Try to find the full path by searching for this folder name on the server
            updateStatus('Resolving folder path...');
            
            try {
                // Use the server's browse-extractions endpoint to find folders with this name
                const response = await fetch(`${SERVER_URL}/api/browse-extractions`, {
                    method: 'GET'
                });
                
                if (response.ok) {
                    const data = await response.json();
                    if (data.success && data.extraction_folders) {
                        // Look for a folder that contains our folder name
                        const matchingFolder = data.extraction_folders.find(folder => 
                            folder.name.includes(folderName) || folder.path.includes(folderName)
                        );
                        
                        if (matchingFolder) {
                            console.log('Found matching folder:', matchingFolder);
                            // Use the full path from the server
                            const extractions = extractFromProjectData(projectData, matchingFolder.path);
                            loadExtractionsData(extractions);
                            updateStatus(`Loaded ${extractions.length} extractions from folder`);
                            return;
                        }
                    }
                }
                
                // If server search fails, try some common base paths
                const commonPaths = [
                    `C:\\Users\\jacob\\Claude\\TEST DOCUMENTS\\${folderName}`,
                    `/mnt/c/Users/jacob/Claude/TEST DOCUMENTS/${folderName}`,
                    folderName  // fallback to just the folder name
                ];
                
                let foundPath = null;
                for (const testPath of commonPaths) {
                    try {
                        const testResponse = await fetch(`${SERVER_URL}/api/browse-extractions`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ folder_path: testPath })
                        });
                        
                        if (testResponse.ok) {
                            const testData = await testResponse.json();
                            if (testData.success) {
                                foundPath = testData.folder_path || testPath;
                                break;
                            }
                        }
                    } catch (e) {
                        // Continue trying other paths
                    }
                }
                
                if (foundPath) {
                    console.log('Found working path:', foundPath);
                    const extractions = extractFromProjectData(projectData, foundPath);
                    loadExtractionsData(extractions);
                    updateStatus(`Loaded ${extractions.length} extractions from folder`);
                } else {
                    // Fallback: load without full paths (images won't work)
                    const extractions = extractFromProjectData(projectData, folderName);
                    loadExtractionsData(extractions);
                    updateStatus(`Loaded ${extractions.length} extractions (images may not load - use direct path entry)`);
                }
                
            } catch (error) {
                console.error('Error resolving folder path:', error);
                // Fallback: load without full paths
                const extractions = extractFromProjectData(projectData, folderName);
                loadExtractionsData(extractions);
                updateStatus(`Loaded ${extractions.length} extractions (path resolution failed)`);
            }
        }

        function refreshData() {
            tryLoadFromLocalStorage();
        }

        function updateStatus(message) {
            document.getElementById('status-text').textContent = message;
            setTimeout(() => {
                document.getElementById('status-text').textContent = 'Ready';
            }, 3000);
        }

        // Modal management
        function setupModalEventListeners() {
            const modal = document.getElementById('extraction-modal');
            const closeButtons = document.querySelectorAll('#close-modal, #close-modal-btn');
            
            // Close modal buttons
            closeButtons.forEach(btn => {
                btn.addEventListener('click', closeModal);
            });
            
            // Close on outside click
            modal.addEventListener('click', function(e) {
                if (e.target === modal) {
                    closeModal();
                }
            });
            
            // Tab switching
            document.querySelectorAll('.tab-btn').forEach(btn => {
                btn.addEventListener('click', function() {
                    const tabName = this.dataset.tab;
                    switchTab(tabName);
                });
            });
            
            // Download button
            document.getElementById('download-extraction-btn').addEventListener('click', function() {
                const extractionId = this.dataset.extractionId;
                if (extractionId) {
                    downloadExtraction(extractionId);
                }
            });
            
            // SPEC drop zone event listeners (for future implementation)
            setupSpecDropZone();
        }

        // SPEC attachment functionality (future enhancement)
        function setupSpecDropZone() {
            const dropZone = document.getElementById('spec-drop-zone');
            const fileInput = document.getElementById('spec-files-input');
            const browseBtn = document.getElementById('browse-spec-files');
            
            // Browse files button
            browseBtn.addEventListener('click', function() {
                fileInput.click();
            });
            
            // File input change
            fileInput.addEventListener('change', function(e) {
                const files = Array.from(e.target.files);
                if (files.length > 0) {
                    handleSpecFiles(files);
                }
            });
            
            // Drag and drop events
            dropZone.addEventListener('dragover', function(e) {
                e.preventDefault();
                e.stopPropagation();
                dropZone.classList.add('drag-over');
            });
            
            dropZone.addEventListener('dragleave', function(e) {
                e.preventDefault();
                e.stopPropagation();
                dropZone.classList.remove('drag-over');
            });
            
            dropZone.addEventListener('drop', function(e) {
                e.preventDefault();
                e.stopPropagation();
                dropZone.classList.remove('drag-over');
                
                const files = Array.from(e.dataTransfer.files).filter(file => 
                    file.type === 'application/pdf'
                );
                
                if (files.length > 0) {
                    handleSpecFiles(files);
                }
            });
        }

        function handleSpecFiles(files) {
            // This is a placeholder for future SPEC attachment functionality
            console.log('SPEC files ready for attachment:', files);
            updateStatus(`Ready to attach ${files.length} SPEC file(s) - Feature coming soon!`);
            
            // Future implementation will:
            // 1. Upload SPEC files to server
            // 2. Associate them with the current extraction
            // 3. Update the extraction record
            // 4. Refresh the files list
        }

        // Show/hide SPEC drop zone based on user permissions or settings
        function toggleSpecDropZone(show = false) {
            const dropZone = document.getElementById('spec-drop-zone');
            if (dropZone) {
                dropZone.style.display = show ? 'block' : 'none';
            }
        }

        function switchTab(tabName) {
            // Update tab buttons
            document.querySelectorAll('.tab-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            document.querySelector(`[data-tab="${tabName}"]`).classList.add('active');
            
            // Update tab content
            document.querySelectorAll('.tab-content').forEach(content => {
                content.classList.remove('active');
            });
            document.getElementById(`tab-${tabName}`).classList.add('active');
        }

        function openModal() {
            ModalUtils.open('extraction-modal');
            document.body.style.overflow = 'hidden';
        }

        function closeModal() {
            ModalUtils.close('extraction-modal');
            document.body.style.overflow = 'auto';
        }

        // Extraction detail functions
        function viewExtractionDetails(extractionId) {
            const extraction = extractionsData.find(ext => ext.id === extractionId);
            if (!extraction) {
                updateStatus('Extraction not found');
                return;
            }
            
            // Populate modal with extraction data
            populateModal(extraction);
            openModal();
        }

        function populateModal(extraction) {
            // Set title and basic info
            document.getElementById('modal-extraction-title').textContent = extraction.extractionName || 'Untitled';
            document.getElementById('modal-equipment-type').textContent = extraction.equipmentType || 'N/A';
            document.getElementById('modal-extraction-type').textContent = extraction.extractionType || 'N/A';
            document.getElementById('modal-page-number').textContent = 
                extraction.pageNumber !== undefined ? `Page ${extraction.pageNumber + 1}` : 'N/A';
            
            // Set image - simplified approach like extraction viewer
            const imageEl = document.getElementById('modal-extraction-image');
            let imagePath = '';
            
            // Get image path - handle both new and old formats
            if (extraction.files?.image) {
                imagePath = extraction.files.image;
            } else if (extraction.imageData) {
                imagePath = extraction.imageData;
            }
            
            if (imagePath) {
                if (imagePath.startsWith('data:')) {
                    // Base64 image data
                    imageEl.src = imagePath;
                    imageEl.style.display = 'block';
                } else {
                    // Check if we have an object URL for this path (folder loading)
                    const objectUrl = findObjectUrl(imagePath);
                    if (objectUrl) {
                        // Use object URL for folder-loaded images
                        imageEl.src = objectUrl;
                        imageEl.style.display = 'block';
                    } else {
                        // File path - try direct path first, then server fallback
                        imageEl.src = imagePath;
                        imageEl.style.display = 'block';
                        imageEl.onerror = function() {
                            // Try server fallback if direct path fails
                            if (this.src.indexOf('/api/extraction-file/') === -1 && serverAvailable) {
                                this.src = `${SERVER_URL}/api/extraction-file/${encodeURIComponent(imagePath)}`;
                            } else {
                                this.style.display = 'none';
                                this.parentElement.innerHTML = '<div style="text-align: center; color: #6c757d; padding: 20px;">Image not available</div>';
                            }
                        };
                    }
                }
            } else {
                imageEl.style.display = 'none';
            }
            
            // Populate OCR content using standalone HTML's approach
            const ocrContentEl = document.getElementById('modal-ocr-content');
            const formatToggle = document.getElementById('format-toggle');
            
            if (extraction.ocrData) {
                // Store extraction data for toggle functionality
                ocrContentEl.extractionData = extraction;
                
                // Initialize with formatted view if table is available
                const hasTable = extraction.ocrData.markdown && (extraction.ocrData.tableData?.isTable || extraction.ocrData.isTable);
                formatToggle.checked = hasTable; // Default to formatted if table available
                formatToggle.disabled = !hasTable; // Disable toggle if no table
                
                // Display content
                const content = displayOCRContent(extraction.ocrData, ocrContentEl, formatToggle.checked);
                ocrContentEl.innerHTML = content || 'No OCR content available';
            } else if (extraction.ocrText) {
                // Legacy fallback
                formatToggle.checked = false;
                formatToggle.disabled = true;
                ocrContentEl.innerHTML = `<div class="raw-markdown">${escapeHtml(extraction.ocrText)}</div>`;
                ocrContentEl.extractionData = extraction;
            } else {
                formatToggle.checked = false;
                formatToggle.disabled = true;
                ocrContentEl.innerHTML = 'No OCR content available';
                ocrContentEl.extractionData = null;
            }
            
            // Populate notes in OCR tab (following standalone HTML pattern)
            const notesSection = document.getElementById('modal-notes-section');
            if (extraction.ocrData) {
                const notes = extraction.ocrData.notes || extraction.ocrData.tableData?.notes;
                const hasNotes = notes?.hasNotes && notes?.entries?.length > 0;
                
                if (hasNotes) {
                    notesSection.innerHTML = `
                        <div class="notes-section">
                            <h4>📋 Installation Notes & Requirements (${notes.count || notes.entries.length})</h4>
                            <ul class="notes-list">
                                ${notes.entries.map(note => `<li>${escapeHtml(note)}</li>`).join('')}
                            </ul>
                        </div>
                    `;
                    notesSection.style.display = 'block';
                } else {
                    notesSection.style.display = 'none';
                }
            } else {
                notesSection.style.display = 'none';
            }
            
            // Note: Table data is now handled by displayOCRContent function
            // Note: Notes are now handled in the OCR tab above
            
            // Populate files
            populateFiles(extraction);
            
            // Set extraction ID for download button
            document.getElementById('download-extraction-btn').dataset.extractionId = extraction.id;
        }

        function populateTableData(extraction) {
            const container = document.getElementById('modal-table-data');
            
            if (extraction.ocrData && extraction.ocrData.tableData) {
                try {
                    const tableData = extraction.ocrData.tableData;
                    
                    if (Array.isArray(tableData) && tableData.length > 0) {
                        // Create table
                        const table = document.createElement('table');
                        table.className = 'ocr-table';
                        
                        // Create header
                        const header = tableData[0];
                        if (typeof header === 'object') {
                            const thead = document.createElement('thead');
                            const headerRow = document.createElement('tr');
                            
                            Object.keys(header).forEach(key => {
                                const th = document.createElement('th');
                                th.textContent = key;
                                headerRow.appendChild(th);
                            });
                            
                            thead.appendChild(headerRow);
                            table.appendChild(thead);
                            
                            // Create body
                            const tbody = document.createElement('tbody');
                            tableData.forEach(row => {
                                const tr = document.createElement('tr');
                                Object.values(row).forEach(value => {
                                    const td = document.createElement('td');
                                    td.textContent = value || '';
                                    tr.appendChild(td);
                                });
                                tbody.appendChild(tr);
                            });
                            
                            table.appendChild(tbody);
                            container.innerHTML = '';
                            container.appendChild(table);
                        } else {
                            container.innerHTML = '<pre>' + JSON.stringify(tableData, null, 2) + '</pre>';
                        }
                    } else {
                        container.innerHTML = 'No table data available';
                    }
                } catch (error) {
                    console.error('Error displaying table data:', error);
                    container.innerHTML = 'Error displaying table data';
                }
            } else {
                container.innerHTML = 'No table data available';
            }
        }

        function populateNotes(extraction) {
            const container = document.getElementById('modal-notes-list');
            
            if (extraction.ocrData && extraction.ocrData.notes && extraction.ocrData.notes.entries) {
                const notes = extraction.ocrData.notes.entries;
                if (Array.isArray(notes) && notes.length > 0) {
                    container.innerHTML = '';
                    notes.forEach(note => {
                        const noteEl = document.createElement('div');
                        noteEl.className = 'note-item';
                        noteEl.textContent = note;
                        container.appendChild(noteEl);
                    });
                } else {
                    container.innerHTML = 'No installation notes available';
                }
            } else if (extraction.notes) {
                container.innerHTML = `<div class="note-item">${extraction.notes}</div>`;
            } else {
                container.innerHTML = 'No installation notes available';
            }
        }

        function populateFiles(extraction) {
            const container = document.getElementById('modal-files-list');
            
            if (extraction.files) {
                container.innerHTML = '';
                
                Object.keys(extraction.files).forEach(fileType => {
                    const filePath = extraction.files[fileType];
                    if (filePath) {
                        const fileEl = document.createElement('div');
                        fileEl.className = 'file-item';
                        
                        const fileExt = filePath.split('.').pop().toUpperCase();
                        const fileIcon = getFileIcon(fileExt);
                        
                        fileEl.innerHTML = `
                            <div class="file-info">
                                <div class="file-icon">${fileIcon}</div>
                                <div>
                                    <div>${fileType}</div>
                                    <div style="font-size: 0.8em; color: #6c757d;">${filePath.split('/').pop()}</div>
                                </div>
                            </div>
                            <button class="action-btn" onclick="downloadFile('${filePath}', '${fileType}')">Download</button>
                        `;
                        
                        container.appendChild(fileEl);
                    }
                });
                
                if (container.children.length === 0) {
                    container.innerHTML = 'No files available';
                }
            } else {
                container.innerHTML = 'No files available';
            }
        }

        function getFileIcon(ext) {
            const icons = {
                'PNG': '🖼',
                'JPG': '🖼',
                'JPEG': '🖼',
                'JSON': '{}',
                'TXT': 'T',
                'PDF': '📄'
            };
            return icons[ext] || '📄';
        }

        function downloadFile(filePath, fileType) {
            // Check if we have the file locally from dragged folder
            if (draggedFiles.has(filePath)) {
                const file = draggedFiles.get(filePath);
                const fileName = filePath.split('/').pop();
                
                // Create download link using the File object
                const a = document.createElement('a');
                a.href = URL.createObjectURL(file);
                a.download = fileName;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                
                // Clean up the temporary object URL
                setTimeout(() => URL.revokeObjectURL(a.href), 1000);
                
                updateStatus(`Downloaded ${fileType} from local files`);
            } else if (serverAvailable) {
                // Use server to serve the file (fallback)
                const encodedPath = encodeURIComponent(filePath);
                const downloadUrl = `${SERVER_URL}/api/extraction-file/${encodedPath}`;
                
                const a = document.createElement('a');
                a.href = downloadUrl;
                a.download = filePath.split('/').pop();
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                
                updateStatus(`Downloading ${fileType} from server...`);
            } else {
                updateStatus('File not available for download');
            }
        }

        function downloadExtraction(extractionId) {
            const extraction = extractionsData.find(ext => ext.id === extractionId);
            if (!extraction) {
                updateStatus('Extraction not found');
                return;
            }
            
            if (extraction.files && serverAvailable) {
                // Download all files
                Object.keys(extraction.files).forEach(fileType => {
                    const filePath = extraction.files[fileType];
                    if (filePath) {
                        setTimeout(() => downloadFile(filePath, fileType), 100);
                    }
                });
                updateStatus(`Downloading all files for ${extraction.extractionName}...`);
            } else {
                updateStatus('No files available for download or server offline');
            }
        }
        
        // Navigate to PDF Viewer while preserving state
        function navigateToPDFViewer() {
            console.log('Navigating to PDF Viewer');
            window.location.href = 'index.html';
        }
    </script>
</body>
</html>